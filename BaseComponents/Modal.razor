@using Microsoft.JSInterop
@inherits ComponentMain.ComponentMain

<style>
    .modal {
        /* Layout */
        display: grid;
        grid-template-rows: auto 1fr auto;
        /* Positioning */
        margin: auto;
        padding: 0;
        position: fixed;
        inset: 0;
        z-index: var(--layer-important);
        /* Sizing */
        max-inline-size: min(90vw, 900px);
        max-block-size: min(80vh, 100%);
        max-block-size: min(80dvb, 100%);
        /* Appearance */
        border: none;
        border-radius: 1rem;
        overflow: hidden;
        /* Fade in/out transition */
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s var(--transition-ease-out);
    }

        .modal > * {
            padding-left: 2rem;
            padding-right: 2rem;
        }

            .modal > *:first-child {
                padding-top: 1rem;
            }

            .modal > *:last-child {
                padding-bottom: 1rem;
            }

        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }

    .modal[modal-type="typSmall"] {
        grid-template-rows: 1fr auto;
    }

    .modal::backdrop {
        background-color: #0005;
        /*    backdrop-filter: blur(2px);*/
        opacity: 0;
        transition: opacity 0.2s var(--transition-ease-out);
    }

    .modal.visible::backdrop {
        opacity: 1;
    }

    /* Content styling */
    .modal > header {
        padding-bottom: 1rem;
        display: flex;
        align-items: center;
        width: 100%;
        gap: 1rem;
        background-color: var(--clr-mono-200);
    }

        .modal > header > .modal-title {
            flex-grow: 1;
            display: flex;
            align-items: center;
            height: 100%;
            gap: 0.8rem;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .modal > header > button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
            height: 2.5rem;
            width: 2.5rem;
            border: none;
            background-color: var(--clr-mono-100);
            border-radius: 9999px;
            cursor: pointer;
        }

    .modal > article {
        padding-block: 1rem;
        overflow-y: auto;
    }

    .modal > footer {
        padding-top: 1rem;
        background-color: var(--clr-mono-200);
    }

        .modal > footer > menu {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 1rem;
        }

</style>

<dialog id=@mstrId class="modal @(fblnIsVisible ? "visible" : "")" @ref=mobjDialog scroll-lock=@(ScrollLock? fblnIsVisible : false) modal-type=@(Title != null ? ModalType : enumModalType.typSmall)>
    @if (ModalType == enumModalType.typLarge && Title != null)
    {
        <header>
            <div class="modal-title">
                @Title
            </div>
            <button type="button" class="shadow-sm" @onclick=@(() => fncHideModal(enumCloseAction.typDisolve))>
                <XIcon />
            </button>
        </header>
    }
    <ScrollContainer MaxHeight="100%">
        <article>
            @ChildContent(this)
        </article>
    </ScrollContainer>
    @if (!HideFooter)
    {
        <footer>
            <menu>
                <Button type="button" autofocus @onclick=@(() => fncHideModal(enumCloseAction.typCancel))>Cancel</Button>
                <Button type="button" @onclick=@(() => fncHideModal(enumCloseAction.typConfirm))>Confirm</Button>
            </menu>
        </footer>
    }
</dialog>

@code {
    #region Enums
    public enum enumCloseAction
    {
        // Cancel button clicked
        typCancel = 0,
        // X, escape, or backdrop was clicked
        typDisolve = 10,
        // Prompt was confirmed
        typConfirm = 20,
    }

    public enum enumModalType
    {
        // Includes the header
        typLarge = 0,
        // Does not include the header / smaller modal popup
        typSmall = 10,
    }
    #endregion

    #region Params
    [Parameter] public RenderFragment? Title { get; set; } = null;
    [Parameter, EditorRequired] public RenderFragment<Modal> ChildContent { get; set; }
    [Parameter] public System.Boolean ScrollLock { get; set; } = false;
    [Parameter] public enumModalType ModalType { get; set; } = enumModalType.typLarge;
    [Parameter] public System.Boolean KeepOpenOnBackdropClick { get; set; } = false;
    [Parameter] public System.Boolean HideFooter { get; set; } = false;
    [Parameter] public EventCallback<enumCloseAction> OnClose { get; set; }
    #endregion

    #region Class Declarations
    private ElementReference mobjDialog { get; set; }
    private System.String mstrId = $"dialog-{subGenerateRandomHex()}";

    private System.Threading.Tasks.TaskCompletionSource<enumCloseAction>? mobjOnCloseReturn = null;
    private Microsoft.JSInterop.IJSObjectReference? mobjJSModalFunctions = null;
    public System.Boolean fblnIsVisible = false;
    #endregion

    #region OnAfterRenderAsync
    protected override async System.Threading.Tasks.Task OnAfterRenderAsync(System.Boolean firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender) return;

        try
        {
            fncKeyBind("escape", BaseComponents.ComponentMain.IKeyBinder.enmExtraKey.typNone, "CloseModal");

            // IJSObjectReference mobjImportedJSModule = await mobjJSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/Modal/index.js");
            // mobjJSModalFunctions = await mobjImportedJSModule.InvokeAsync<IJSObjectReference>("initModal", DotNetObjectReference.Create(this), KeepOpenOnBackdropClick);
            mobjJSModalFunctions = await mobjJSRuntime.InvokeAsync<Microsoft.JSInterop.IJSObjectReference>("js", @"
                const DotNet = params[0];
                const keepOpenOnBackdropClick = params[1];

                const checkIfBackdropClicked = (modalEl) => {
                    return (event) => {
                        var rect = modalEl.getBoundingClientRect();
                        var isInDialog = (rect.top <= event.clientY && event.clientY <= rect.top + rect.height &&
                            rect.left <= event.clientX && event.clientX <= rect.left + rect.width);
                        if (!isInDialog && event.target.tagName === 'DIALOG') {
                            event.stopPropagation()
                            DotNet.invokeMethodAsync('fncHideModal', 10);
                        }
                    }
                }

                return {
                    showModal: (modalEl) => {
                        modalEl?.showModal();
                        if (!keepOpenOnBackdropClick)
                            modalEl.addEventListener('mousedown', checkIfBackdropClicked(modalEl));
                    },
                    hideModal: (modalEl) => {
                        setTimeout(() => modalEl.close(), 200);
                        if (!keepOpenOnBackdropClick)
                            modalEl.removeEventListener('mousedown', checkIfBackdropClicked(modalEl))
                    },
                }", 
                Microsoft.JSInterop.DotNetObjectReference.Create(this), KeepOpenOnBackdropClick);
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region fncShowModal
    public async System.Threading.Tasks.Task<enumCloseAction> fncShowModal()
    {
        mobjOnCloseReturn = new System.Threading.Tasks.TaskCompletionSource<enumCloseAction>();

        fblnIsVisible = true;
        StateHasChanged();
        mobjJSModalFunctions?.InvokeVoidAsync("showModal", mobjDialog);

        return await mobjOnCloseReturn.Task;
    }
    #endregion

    #region fncHideModal
    [JSInvokable("fncHideModal")]
    public void fncHideModal(enumCloseAction penmCloseAction)
    {
        fblnIsVisible = false;
        StateHasChanged();
        mobjJSModalFunctions?.InvokeVoidAsync("hideModal", mobjDialog);

        if (mobjOnCloseReturn != null)
        {
            mobjOnCloseReturn.SetResult(penmCloseAction);
            mobjOnCloseReturn = null;
        }

        OnClose.InvokeAsync(penmCloseAction);
    }
    #endregion

    #region subKeyPressed
    public override void subKeyPressed(System.String pstrKeyBindIdentifier)
    {
        switch (pstrKeyBindIdentifier)
        {
            case "CloseModal":
                fncHideModal(enumCloseAction.typDisolve);
                break;
        }
    }
    #endregion
    }