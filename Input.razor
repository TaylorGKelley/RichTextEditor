@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using RichTextEditor.BaseComponents
@using RichTextEditor.BaseComponents.Icons
@using RichTextEditor.BaseComponents.InputMain
@inherits InputMain<System.Collections.Generic.List<Classes.cRichTextBlock>?>
@implements IDisposable

<style type="text/css">
    .rich-text-input * {
    font-family: Arial, sans-serif;
    }

    .rich-text-input h1 {
    font-size: 1.75rem;
    }

    .rich-text-input h2 {
    font-size: 1.5rem;
    }

    .rich-text-input h3 {
    font-size: 1.25rem;
    }

    .rich-text-input div.text-block {
    /* Body Text */
    font-size: 1rem;
    }

    .rich-text-input blockquote.text-block {
    position: relative;
    padding: 0.5rem;
    padding-left: 1rem;
    background-color: #eee;
    }

    .rich-text-input blockquote.text-block::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 3px;
    height: 100%;
    background-color: #555;
    }

    .rich-text-input .text-block[data-indentation] {
    /* Bullet list */
    padding-left: 1.5rem;
    }

    .rich-text-input .text-block[data-indentation]::before {
    content: '';
    position: absolute;
    left: 0.75rem;
    top: 45%;
    transform: translate(-50%, -50%);
    width: 5px;
    aspect-ratio: 1;
    border-radius: 50%;
    background-color: black;
    }

    .rich-text-input {
    border: 1px solid #ccc;
    border-radius: 1rem;
    overflow: hidden;
    position: relative;
    width: 500px;
    }

    .rich-text-input[disabled] * {
    pointer-events: none;
    cursor: default;
    }

    .rich-text-input *[contenteditable]:focus {
    outline: none;
    }

    .editor-control-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    border-bottom: 1px solid #ccc;
    background-color: #fafafa;
    }

    .rich-text-input .editor-control-bar > select {
    padding: 0.25rem 1rem;
    background-color: transparent;
    border: 1px solid #777;
    border-radius: 0.5rem;
    cursor: pointer;
    }

    /* .rich-text-input .editor-control-bar > select:hover { */
    /* background-color: transparent; */
    /* } */

    .rich-text-input .editor-control-bar > select:focus {
    outline: none;
    }

    .rich-text-input .editor-control-bar > button {
    display: inline-block;
    width: 2rem;
    height: 2rem;
    background-color: transparent;
    color: #555;
    padding: 0.4rem;
    border: 1px solid transparent;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.1s ease-in-out;
    }

    .rich-text-input .editor-control-bar > button:not(:disabled):hover {
    background-color: #e3e3e3;
    border-color: #777;
    color: #111;
    }

    .rich-text-input .editor-control-bar > button:not(:disabled).active {
    background-color: #e5e5e5;
    border-color: #999;
    color: #333;
    }

    .editor-content {
    background-color: white;
    position: relative;
    padding: 1rem;
    width: 100%;
    height: 500px;
    overflow-y: auto;
    overflow-x: clip;
    scrollbar-width: none;
    cursor: text;
    }

    .editor-content:has(:first-child.image-block .full-width) {
    padding-top: 0;
    }

    .rich-text-input .text-block {
    position: relative;
    margin-bottom: 0.5rem;
    line-height: 1.5;
    }

    .rich-text-input .bold {
    font-weight: bold;
    }

    .rich-text-input .italic {
    font-style: italic;
    }

    .rich-text-input .underline {
    text-decoration: underline;
    }

    .rich-text-input span[href] {
    color: blue;
    cursor: pointer;
    }

    .rich-text-input .placeholder {
    color: #555;
    user-select: none;
    }

    .rich-text-input .image-block {
    position: relative;
    width: 100%;
    margin-bottom: 0.5rem;
    padding-bottom: 24px;
    cursor: auto;
    display: flex;
    align-items: center;
    user-select: none;
    }

    .rich-text-input .image-block.align-left {
    justify-content: flex-start;
    }

    .rich-text-input .image-block.align-center {
    justify-content: center;
    }

    .rich-text-input .image-block.align-right {
    justify-content: flex-end;
    }

    .rich-text-input .image-block-container {
    position: relative;
    width: 100%;
    }

    .rich-text-input .image-block-container.full-width img {
    position: absolute;
    height: 100%;
    width: calc(100% + 2rem);
    border-radius: 0;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    }

    .rich-text-input .image-block-container > button.image-block-delete {
    display: inline-block;
    position: absolute;
    top: 0;
    right: 0;
    margin: 0.25rem;
    height: 35px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color 0.1s ease-in-out;
    border-radius: 50%;
    aspect-ratio: 1;
    border: none;
    cursor: pointer;
    z-index: 20;
    background-color: #fffa;
    }

    .rich-text-input:not(:disabled) .image-block-container > button.image-block-delete:hover {
    background-color: #ffff;
    }

    .rich-text-input .image-block-container > button.image-block-delete > svg {
    height: 100%;
    }

    .rich-text-input .image-block-container > input {
    position: absolute;
    bottom: 0;
    transform: translateY(100%);
    left: 0;
    padding: 4px 3px;
    border: none;
    outline: none;
    cursor: text;
    background: none;
    color: #444;
    width: 100%;
    }

    .rich-text-input .image-block-container > input:focus {
    outline: none;
    }

    .rich-text-input .image-resize-container {
    position: relative;
    width: 100%;
    height: 100%;
    }

    .rich-text-input .image-resize-container > .image-resize-handle {
    position: absolute;
    top: 0;
    width: 10px;
    height: 100%;
    cursor: col-resize;
    z-index: 10;
    }

    .rich-text-input .image-resize-container > .image-resize-handle:first-child {
    left: 0;
    }

    .rich-text-input .image-resize-container > .image-resize-handle:last-child {
    right: 0;
    }

    .rich-text-input .image-resize-container > .image-resize-handle-height {
    width: calc(100% - 20px);
    height: 10px;
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    cursor: row-resize;
    z-index: 9;
    }

    .rich-text-input .image-resize-container > .image-resize-handle,
    .rich-text-input .image-resize-container > .image-resize-handle-height {
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .rich-text-input .image-resize-container > img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    box-shadow: 0 0 3px 1px rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    }
</style>

<InputContainer Ref=@this TRef=@Input TValue=@(System.Collections.Generic.List<Classes.cRichTextBlock>)>
    <div id=@Id class="rich-text-input" disabled=@prpIsDisabled @ref=@fobjEditorRef @oninput=@subHandleCurrentSelectionChange placeholder=@(!System.String.IsNullOrWhiteSpace(Placeholder) ? Placeholder : "Click here to start typing...")>
        <div class="editor-control-bar">
            <select class="block-type-select" disabled=@prpIsDisabled @onchange=@subHandleBlockTypeChange>
                <option value="typBody">Body</option>
                <option value="typHeading1">Heading 1</option>
                <option value="typHeading2">Heading 2</option>
                <option value="typHeading3">Heading 3</option>
                <option value="typBulletList">Bullet List</option>
                <option value="typBlockQuote">Block Quote</option>
                <option value="typImage" disabled>Image</option>
            </select>
            <button type="button" id="bold" class="editor-control-bar__style-button" disabled=@prpIsDisabled @onclick=@(() => subHandleApplyStyle("bold"))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 4H14C15.0609 4 16.0783 4.42143 16.8284 5.17157C17.5786 5.92172 18 6.93913 18 8C18 9.06087 17.5786 10.0783 16.8284 10.8284C16.0783 11.5786 15.0609 12 14 12H6V4Z"
                    stroke-width="3"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M6 12H15C16.0609 12 17.0783 12.4214 17.8284 13.1716C18.5786 13.9217 19 14.9391 19 16C19 17.0609 18.5786 18.0783 17.8284 18.8284C17.0783 19.5786 16.0609 20 15 20H6V12Z"
                    stroke-width="3"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="italic" class="editor-control-bar__style-button" disabled=@prpIsDisabled @onclick=@(() => subHandleApplyStyle("italic"))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 4H10"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M14 20H5"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M15 4L9 20"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="underline" class="editor-control-bar__style-button" disabled=@prpIsDisabled @onclick=@(() => subHandleApplyStyle("underline"))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 3V10C6 11.5913 6.63214 13.1174 7.75736 14.2426C8.88258 15.3679 10.4087 16 12 16C13.5913 16 15.1174 15.3679 16.2426 14.2426C17.3679 13.1174 18 11.5913 18 10V3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M4 21H20"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="link" class="editor-control-bar__style-button" disabled=@prpIsDisabled @onclick=@subHandleLinkStyle>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M10 13C10.4295 13.5741 10.9774 14.0492 11.6066 14.3929C12.2357 14.7367 12.9315 14.9411 13.6467 14.9923C14.3618 15.0436 15.0796 14.9404 15.7513 14.6898C16.4231 14.4392 17.0331 14.0471 17.54 13.54L20.54 10.54C21.4508 9.59699 21.9548 8.33398 21.9434 7.023C21.932 5.71201 21.4061 4.45795 20.4791 3.53091C19.5521 2.60387 18.298 2.07803 16.987 2.06663C15.676 2.05524 14.413 2.55921 13.47 3.47L11.75 5.18"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M14 11C13.5705 10.4259 13.0226 9.95081 12.3935 9.60706C11.7643 9.2633 11.0685 9.05888 10.3534 9.00766C9.63821 8.95645 8.92041 9.05963 8.24866 9.31021C7.5769 9.5608 6.96689 9.95293 6.46 10.46L3.46 13.46C2.54921 14.403 2.04524 15.666 2.05663 16.977C2.06802 18.288 2.59387 19.542 3.52091 20.4691C4.44795 21.3961 5.70201 21.922 7.013 21.9334C8.32398 21.9448 9.58699 21.4408 10.53 20.53L12.24 18.82"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="image" class="editor-control-bar__image-button" disabled=@prpIsDisabled @onclick=@subHandleImageInsert>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3Z"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M8.5 10C9.32843 10 10 9.32843 10 8.5C10 7.67157 9.32843 7 8.5 7C7.67157 7 7 7.67157 7 8.5C7 9.32843 7.67157 10 8.5 10Z"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 15L16 10L5 21"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="typLeft" class="editor-control-bar__align-button" disabled=@prpIsDisabled @onclick=@(() => subHandleTextAlign(Classes.enumTextAlign.typLeft))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M17 10H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 6H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 14H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M17 18H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="typCenter" class="editor-control-bar__align-button" disabled=@prpIsDisabled @onclick=@(() => subHandleTextAlign(Classes.enumTextAlign.typCenter))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M18 10H6"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 6H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 14H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M18 18H6"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
            <button type="button" id="typRight" class="editor-control-bar__align-button" disabled=@prpIsDisabled @onclick=@(() => subHandleTextAlign(Classes.enumTextAlign.typRight))>
                <svg style="stroke: currentColor"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 10H7"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 6H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 14H3"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                    <path d="M21 18H7"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round" />
                </svg>
            </button>
        </div>
        <div class="editor-content">
            <!-- Content Editable blocks are dynamically insterted here -->
        </div>
    </div>
</InputContainer>

<Modal @ref=@fobjImageModalRef ScrollLock ModalType=@Modal.enumModalType.typLarge>
    <Title>
        <span style="height: 100%;">
            <ImageIcon />
        </span>
        <span>Upload Image</span>
    </Title>
    <ChildContent>
        <FileInput @bind-Value=falobjImage Type=@FileInput.enumType.typImage />
    </ChildContent>
</Modal>

<Modal HideFooter @ref=@fobjLinkModalRef ScrollLock ModalType=@Modal.enumModalType.typSmall>
    <div style="padding: 1rem;">
        <RichTextEditor.BaseComponents.Form.Form OnValidate=@(() => fncValidateUri(fstrModalLink))
        OnSubmit=@(() => context.fncHideModal(Modal.enumCloseAction.typConfirm))>
            <TextInput Placeholder="Enter your link" Label="Link" ErrorMessage=@fstrModalLinkErrorMessage @bind-Value=@fstrModalLink />
            <RichTextEditor.BaseComponents.Form.SubmitButton>Confirm</RichTextEditor.BaseComponents.Form.SubmitButton>
        </RichTextEditor.BaseComponents.Form.Form>
    </div>
</Modal>

@code {
    #region Class Declarations
    public System.Boolean mblnContentChanged = false;

    private ElementReference? fobjEditorRef = null;
    private Modal? fobjImageModalRef = null;
    private Modal? fobjLinkModalRef = null;
    private IJSObjectReference? mobjJSRichTextEditor = null;

    private System.String? fstrModalLink { get; set; } = null;
    private System.String? fstrModalLinkErrorMessage;
    private System.Collections.Generic.List<Classes.cFileUpload>? falobjImage { get; set; } = null;

    public static System.String mstrImageFormatType = "image/webp";
    private System.Collections.Generic.Dictionary<System.String, System.String> mdictImages =
        new System.Collections.Generic.Dictionary<System.String, System.String>();
    #endregion

    // When migrating to .Net 8+, make a WASM component and use OnParametersSet instead of OnAfterRenderAsync if blazor hybrid app is used
    // protected override void OnParametersSet()
    // {
    //     
    // }

    #region OnAfterRenderAsync
    protected override async System.Threading.Tasks.Task OnAfterRenderAsync(System.Boolean firstRender)
    {
        try
        {
            await base.OnAfterRenderAsync(firstRender);

            if (mblnContentChanged) {
                return;
            }

            await subRefreshContent();
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region subRefreshContent
    public async System.Threading.Tasks.Task subRefreshContent()
    {
        System.String strJSONCurrentValue = System.Text.Json.JsonSerializer.Serialize(mobjCurrentValue, Classes.Constants.cJSONConversion.objOptions);

        if (mobjJSRichTextEditor is null)
        {
            // IJSObjectReference objJSModule = await mobjJSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/Components/RichTextInput/index.js");
            // mobjJSRichTextEditor = await objJSModule.InvokeAsync<IJSObjectReference>("initialize", fobjEditorRef, strJSONCurrentValue, DotNetObjectReference.Create(this));

            const System.String strJSScript = @"
const BlockTypes = {
    // Text Block Types
    typBody: 'typBody',
    typHeading1: 'typHeading1',
    typHeading2: 'typHeading2',
    typHeading3: 'typHeading3',
    typBulletList: 'typBulletList',
    typBlockQuote: 'typBlockQuote',
    // Image Block Type
    typImage: 'typImage',
};

const AlignTypes = {
    typLeft: 'typLeft',
    typCenter: 'typCenter',
    typRight: 'typRight',
};

class CursorSelection {
    //#region placeCursorAtIndex(element, startIndex,	endIndex, { logErrors })
    static placeCursorAtIndex(
        element,
        startIndex,
        endIndex = undefined,
        options = { logErrors: false }
    ) {
        const range = document.createRange();
        const selection = window.getSelection();

        // Helper to find the correct position in the element's child nodes
        function setRangeAtIndex(node, type) {
            if (type === 'end' && !endIndex) return true;

            if (node.nodeType === Node.TEXT_NODE) {
                const textLength = node.textContent.length;
                // Allow placement in empty text nodes
                if (
                    (type === 'start' && startIndex <= textLength) ||
                    (type === 'end' && endIndex <= textLength)
                ) {
                    if (type === 'start') {
                        range.setStart(node, startIndex); // Place the start range
                    } else if (type === 'end') {
                        range.setEnd(node, endIndex); // Place the end range
                    }
                    return true; // Stop traversal
                } else {
                    // Decrement offsets for non-matching nodes
                    if (type === 'start') {
                        startIndex -= textLength;
                    } else if (type === 'end') {
                        endIndex -= textLength;
                    }
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const children = Array.from(node.childNodes);
                // If no children exist, consider the element itself for placement
                if (children.length === 0) {
                    if (type === 'start') {
                        range.setStart(node, 0);
                    } else if (type === 'end') {
                        range.setEnd(node, 0);
                    }
                    return true;
                }

                // Traverse child nodes in the correct order for start/end
                for (var i = 0; i < children.length; i++) {
                    if (setRangeAtIndex(children[i], type, i >= children.length)) {
                        return true; // Stop traversal
                    }
                }
            }

            return false;
        }
        // Attempt to set the range at the given index
        if (!setRangeAtIndex(element, 'start')) {
            if (options.logErrors)
                console.error(`Unable to place cursor start at index ${startIndex}.`);
            return false;
        }

        if (endIndex) {
            if (!setRangeAtIndex(element, 'end')) {
                if (options.logErrors)
                    console.error(`Unable to place cursor end at index ${endIndex}.`);
                return false;
            }
        } else {
            range.collapse(true);
        }
        // Clear existing selection and set the new range
        selection.removeAllRanges();
        selection.addRange(range);
        return true;
    }
    //#endregion

    //#region getCursorRangeInElement
    static getCursorRangeInElement(element) {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            return null;
        }
        const range = selection.getRangeAt(0); // Get the first range of the selection

        if (
            !element.contains(range.commonAncestorContainer) ||
            range.startContainer === element
        ) {
            return null;
        }
        // Helper function to calculate offset relative to the element
        function calculateOffset(node, offset) {
            let totalOffset = 0;
            function traverseNodes(currentNode) {
                if (currentNode === node) {
                    totalOffset += offset;
                    return true;
                }
                if (currentNode.nodeType === Node.TEXT_NODE) {
                    totalOffset += currentNode.textContent.length;
                } else if (currentNode.nodeType === Node.ELEMENT_NODE) {
                    for (const child of currentNode.childNodes) {
                        if (traverseNodes(child)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            traverseNodes(element);
            return totalOffset;
        }

        const startOffset = calculateOffset(
            range.startContainer,
            range.startOffset
        );
        const endOffset = calculateOffset(range.endContainer, range.endOffset);
        const wrappingElement = range.commonAncestorContainer.parentElement; // get's the span wrapping the text

        return { startOffset, endOffset, wrappingElement };
    }
    //#endregion
}

class TextBlock {
    //#region Fields
    /** @type {BlockTypes} */
    blockType;
    /** @type {number} */
    indentation = 0;
    /** @type {typeof keyof AlignTypes} */
    textAlign = AlignTypes.typLeft;
    /** @type {Array<TextNode>} */
    textNodes;
    //#endregion

    //#region Constructor
    constructor(
        blockType = BlockTypes.typBody,
        indentation = 0,
        textAlign = AlignTypes.typLeft,
        textNodes = [new TextNode('\u200b')]
    ) {
        Object.assign(this, { blockType, indentation, textAlign, textNodes });
    }
    //#endregion
}

class TextNode {
    //#region Fields
    text;
    isBold = false;
    isUnderline = false;
    isItalic = false;
    link;
    //#endregion

    //#region Constructor
    constructor(
        text = '\u200b',
        { isBold, isUnderline, isItalic, link } = {
            isBold: false,
            isUnderline: false,
            isItalic: false,
        }
    ) {
        Object.assign(this, {
            text,
            isBold,
            isUnderline,
            isItalic,
            link,
        });
    }
    //#endregion
}

class ImageBlockData {
    //#region Fields
    /** @type {string} */
    src;
    /** @type {string} */
    caption;
    /** @type {string} */
    alt;
    /** @type {number} */
    width;
    /** @type {number} */
    heightRatio;
    /** @type {keyof typeof AlignTypes} */
    align = AlignTypes.typCenter;
    /** @type {string} */
    imageId;
    //#endregion

    //#region Constructor
    constructor(
        src = undefined,
        imageId = undefined,
        caption = undefined,
        alt = '',
        width = 70,
        heightRatio = 0.5625, // Default of 16:9
    ) {
        Object.assign(this, { src, caption, alt, width, heightRatio, imageId });
    }
    //#endregion
}

class ImageBlock {
    //#region Fields
    /** @type {(currentNode) => void} */
    #setCurrentNode;
    /** @type {(currentSelection) => void} */
    #setCurrentSelection;
    /** @type {HTMLDivElement} */
    #element;
    /** @type {'typImage'} */
    blockType = BlockTypes.typImage;
    /** @type {ImageBlockData} */
    data;
    /** @type {HTMLButtonElement} */
    deleteButton;

    /** @type {HTMLDivElement} */
    #resizableContainer;
    /** @type {HTMLDivElement} */
    #resizeHandleLeft;
    /** @type {HTMLDivElement} */
    #resizeHandleBottom;
    /** @type {HTMLDivElement} */
    #resizeHandleRight;

    /** @type {boolean} */
    #isResizingWidth = false;
    /** @type {boolean} */
    #isResizingHeight = false;
    /** @type {number} */
    #containerWidth;
    //#endregion

    //#region Properties
    /** @type {HTMLDivElement} */
    get element() {
        return this.#element;
    }
    //#endregion

    //#region Constructor
    /**
     *
     * @param {ImageBlockData} data
     * @param {(currentSelection) => void} setCurrentNode Used as a callback to set the currently focused node
     * @param {(currentSelection) => void} setCurrentSelection Used as a callback to set the currently focused selection
     */
    constructor(
        data = new ImageBlockData(),
        setCurrentNode = () => { },
        setCurrentSelection = () => { }
    ) {
        this.data = data;
        this.#setCurrentNode = setCurrentNode;
        this.#setCurrentSelection = setCurrentSelection;

        this.#element = this.#renderBlock();

        if (this.data.align !== AlignTypes.typLeft)
            this.#resizeHandleLeft.addEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        if (this.data.align !== AlignTypes.typRight)
            this.#resizeHandleRight.addEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        this.#resizeHandleBottom.addEventListener(
            'mousedown',
            this.#handleHeightResizeMouseDown.bind(this)
        );
    }
    //#endregion

    //#region dispose
    /**
     * Removes Event Listeners and DOM element
     */
    dispose() {
        if (this.data.align !== AlignTypes.typLeft)
            this.#resizeHandleLeft.removeEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        if (this.data.align !== AlignTypes.typRight)
            this.#resizeHandleRight.removeEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        this.#resizeHandleBottom.removeEventListener(
            'mousedown',
            this.#handleHeightResizeMouseDown.bind(this)
        );

        this.#element.remove();
    }
    //#endregion

    //#region setDisabled(isDisabled)
    setDisabled(isDisabled) {
        // Remove event listeners to prevent multiple active listeners
        if (this.data.align !== AlignTypes.typLeft)
            this.#resizeHandleLeft.removeEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        if (this.data.align !== AlignTypes.typRight)
            this.#resizeHandleRight.removeEventListener(
                'mousedown',
                this.#handleWidthResizeMouseDown.bind(this)
            );

        this.#resizeHandleBottom.removeEventListener(
            'mousedown',
            this.#handleHeightResizeMouseDown.bind(this)
        );

        // Add back if it's not disabled
        if (!isDisabled) {
            if (this.data.align !== AlignTypes.typLeft)
                this.#resizeHandleLeft.addEventListener(
                    'mousedown',
                    this.#handleWidthResizeMouseDown.bind(this)
                );

            if (this.data.align !== AlignTypes.typRight)
                this.#resizeHandleRight.addEventListener(
                    'mousedown',
                    this.#handleWidthResizeMouseDown.bind(this)
                );

            this.#resizeHandleBottom.addEventListener(
                'mousedown',
                this.#handleHeightResizeMouseDown.bind(this)
            );
        }
    }
    //#endregion

    //#region #renderBlock()
    /** @returns {HTMLDivElement} */
    #renderBlock() {
        const imageBlock = document.createElement('div');
        imageBlock.classList.add('image-block');
        imageBlock.classList.add(`align-${this.data.align.slice(3).toLowerCase()}`);
        this.#resizableContainer = document.createElement('div');
        this.#resizableContainer.classList.add('image-block-container');
        if (this.data.width === 100) {
            this.#resizableContainer.classList.add('full-width');
            this.#resizableContainer.style.width = '100%';
        } else {
            this.#resizableContainer.style.width = `${this.data.width}%`;
        }
        this.#resizableContainer.style.aspectRatio = `1 / ${this.data.heightRatio}`;
        imageBlock.appendChild(this.#resizableContainer);

        this.deleteButton = document.createElement('button');
        this.deleteButton.type = 'button';
        this.deleteButton.classList.add('image-block-delete');
        this.deleteButton.innerHTML = `
			<svg style='stroke: currentColor;' viewBox='0 0 20 22' fill='none' xmlns='http://www.w3.org/2000/svg'>
				<path d='M1 5H3M3 5H19M3 5V19C3 19.5304 3.21071 20.0391 3.58579 20.4142C3.96086 20.7893 4.46957 21 5 21H15C15.5304 21 16.0391 20.7893 16.4142 20.4142C16.7893 20.0391 17 19.5304 17 19V5M6 5V3C6 2.46957 6.21071 1.96086 6.58579 1.58579C6.96086 1.21071 7.46957 1 8 1H12C12.5304 1 13.0391 1.21071 13.4142 1.58579C13.7893 1.96086 14 2.46957 14 3V5M8 10V16M12 10V16' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/>
			</svg>`;
        this.#resizableContainer.appendChild(this.deleteButton);

        const imageContainer = document.createElement('div');
        imageContainer.classList.add('image-resize-container');

        this.#resizableContainer.appendChild(imageContainer);

        this.#resizeHandleLeft = document.createElement('div');
        this.#resizeHandleLeft.classList.add('image-resize-handle');
        this.#resizeHandleLeft.innerHTML = `
		<svg width='11' height='36' viewBox='0 0 11 36' fill='none' xmlns='http://www.w3.org/2000/svg'>
			<g filter='url(#filter0_d_264_2)'>
				<rect x='3' y='3' width='5' height='30' rx='2.5' fill='#AAAAAA'/>
				<rect x='3.5' y='3.5' width='4' height='29' rx='2' stroke='white'/>
			</g>
			<defs>
				<filter id='filter0_d_264_2' x='0.9' y='0.9' width='9.2' height='34.2' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'>
					<feFlood flood-opacity='0' result='BackgroundImageFix'/>
					<feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/>
					<feOffset/>
					<feGaussianBlur stdDeviation='1.05'/>
					<feComposite in2='hardAlpha' operator='out'/>
					<feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0'/>
					<feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_264_2'/>
					<feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_264_2' result='shape'/>
				</filter>
			</defs>
		</svg>`;

        this.#resizeHandleBottom = document.createElement('div');
        this.#resizeHandleBottom.classList.add('image-resize-handle-height');
        this.#resizeHandleBottom.innerHTML = `
		<svg width='36' height='11' viewBox='0 0 36 11' fill='none' xmlns='http://www.w3.org/2000/svg'>
			<g filter='url(#filter0_d_264_3)'>
				<rect x='3' y='8' width='5' height='30' rx='2.5' transform='rotate(-90 3 8)' fill='#AAAAAA'/>
				<rect x='3.5' y='7.5' width='4' height='29' rx='2' transform='rotate(-90 3.5 7.5)' stroke='white'/>
			</g>
			<defs>
				<filter id='filter0_d_264_3' x='0.9' y='0.9' width='34.2' height='9.2' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'>
					<feFlood flood-opacity='0' result='BackgroundImageFix'/>
					<feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/>
					<feOffset/>
					<feGaussianBlur stdDeviation='1.05'/>
					<feComposite in2='hardAlpha' operator='out'/>
					<feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0'/>
					<feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_264_3'/>
					<feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_264_3' result='shape'/>
				</filter>
			</defs>
		</svg>`;

        this.#resizeHandleRight = document.createElement('div');
        this.#resizeHandleRight.classList.add('image-resize-handle');
        this.#resizeHandleRight.innerHTML = `
		<svg width='11' height='36' viewBox='0 0 11 36' fill='none' xmlns='http://www.w3.org/2000/svg'>
			<g filter='url(#filter0_d_264_2)'>
				<rect x='3' y='3' width='5' height='30' rx='2.5' fill='#AAAAAA'/>
				<rect x='3.5' y='3.5' width='4' height='29' rx='2' stroke='white'/>
			</g>
			<defs>
				<filter id='filter0_d_264_2' x='0.9' y='0.9' width='9.2' height='34.2' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'>
					<feFlood flood-opacity='0' result='BackgroundImageFix'/>
					<feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/>
					<feOffset/>
					<feGaussianBlur stdDeviation='1.05'/>
					<feComposite in2='hardAlpha' operator='out'/>
					<feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0'/>
					<feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_264_2'/>
					<feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_264_2' result='shape'/>
				</filter>
			</defs>
		</svg>`;

        if (this.data.align !== AlignTypes.typLeft)
            imageContainer.appendChild(this.#resizeHandleLeft);

        const imgElement = document.createElement('img');
        imgElement.src = this.data.src;
        imgElement.alt = this.data.alt || this.data.caption || '';
        imgElement.title = this.data.alt || this.data.caption || '';
        imageContainer.appendChild(imgElement);

        imageContainer.appendChild(this.#resizeHandleBottom);

        if (this.data.align !== AlignTypes.typRight)
            imageContainer.appendChild(this.#resizeHandleRight);

        // On focus for the input, run the setCurrentNode/Selection
        // Work out events for selecting
        const captionInput = document.createElement('input');
        captionInput.type = 'text';
        captionInput.classList.add('image-caption');
        captionInput.placeholder = 'Caption';
        captionInput.value = this.data.caption || '';
        captionInput.addEventListener('focus', () => {
            this.#setCurrentNode();
            this.#setCurrentSelection({
                startOffset: 0,
                endOffset: 0,
                beforeSelection: [],
                insideSelection: [],
                afterSelection: [],
            });
        });
        captionInput.addEventListener('input', (e) => {
            this.data.caption = e.target.value;
        });
        this.#resizableContainer.appendChild(captionInput);

        return imageBlock;
    }
    //#endregion

    //#region #handleMouseDown(e)
    #handleWidthResizeMouseDown(e) {
        this.#isResizingWidth = true;
        this.#startResize(e);
    }

    #handleHeightResizeMouseDown(e) {
        this.#isResizingHeight = true;
        this.#startResize(e);
    }
    //#endregion

    //#region #calculateNewSize(e)
    #calculateNewSize(e) {
        const rect = this.#resizableContainer.getBoundingClientRect();

        if (this.#isResizingWidth) {
            let newWidth = rect.width;
            switch (this.data.align) {
                case AlignTypes.typCenter:
                    newWidth = Math.abs(
                        Math.floor(rect.left + rect.width / 2 - e.clientX) * 2
                    );
                    break;
                case AlignTypes.typLeft:
                    newWidth = Math.floor(e.clientX - rect.left);
                    break;
                case AlignTypes.typRight:
                    newWidth = Math.floor(rect.right - e.clientX);
                    break;
            }

            return newWidth + 5; // Add 5px to account for the handle padding
        } else if (this.#isResizingHeight) {
            return e.clientY - rect.top + 5;
        }
    }
    //#endregion

    //#region #startResize(e)
    #startResize(e) {
        this.#containerWidth = this.#element.getBoundingClientRect().width;

        document.addEventListener('mousemove', this.#resize.bind(this));
        document.addEventListener('mouseup', this.#stopResize.bind(this));

        this.#resize(e); // Update once on click
    }
    //#endregion

    //#region #resize(e)
    #resize(e) {
        const newSize = this.#calculateNewSize(e);

        if (this.#isResizingWidth) {
            const newWidth = Math.ceil((newSize / this.#containerWidth) * 100);
            if (newWidth > 20 && newWidth < 100) {
                this.data.width = newWidth;

                this.#resizableContainer.style.width = `${this.data.width}%`;
                this.#resizableContainer.classList.remove('full-width');
            } else if (newWidth >= 100) {
                this.data.width = 100;

                this.#resizableContainer.style.width = '100%';
                this.#resizableContainer.classList.add('full-width');
            }
        } else if (this.#isResizingHeight) {
            const newHeightRatio =
                Math.trunc(
                    (newSize / this.#resizableContainer.getBoundingClientRect().width) *
                    10000
                ) / 10000;

            if (newHeightRatio > 0.3 && newHeightRatio < 1.25) {
                this.data.heightRatio = newHeightRatio;

                this.#resizableContainer.style.aspectRatio = `1 / ${this.data.heightRatio}`;
            }
        }
    }
    //#endregion

    //#region #stopResize()
    #stopResize() {
        this.#isResizingWidth = false;
        this.#isResizingHeight = false;
        document.removeEventListener('mousemove', this.#resize.bind(this));
        document.removeEventListener('mouseup', this.#stopResize.bind(this));
    }
    //#endregion
}

class EditableBlock {
    //#region Fields
    /** @type {HTMLElement} */
    #editor;
    /** @type {boolean} */
    #isMac;
    /** @type {boolean} */
    #focusInsideEditor = false;
    /** @type {BlockTypes} */
    #blockType;
    /** @type {keyof typeof AlignTypes} */
    #textAlign = AlignTypes.typLeft;
    /** @type {Array<TextNode>} */
    #content = [];
    /** @type {(currentSelection) => void} */
    #setCurrentNode;
    /** @type {(currentSelection) => void} */
    #setCurrentSelection;
    /** @type {number} */
    #indentation = 0;
    /** @type {MutationObserver} */
    #observer;
    /** @type {Object} */
    currentSelection = {};

    /** @type {Array<TextNode>} */
    static defaultContent = [new TextNode()];
    //#endregion

    //#region Properties
    get element() {
        return this.#editor;
    }

    get content() {
        return this.#content;
    }
    set content(value) {
        this.#content = value;
    }

    get indentation() {
        return this.#blockType === BlockTypes.typBulletList
            ? this.#indentation
            : undefined;
    }

    set indentation(value) {
        if (this.#blockType === BlockTypes.typBulletList) {
            this.#indentation = value;

            this.#editor.setAttribute('data-indentation', this.#indentation);
            this.#editor.style =
                this.#indentation > 0 ? `margin-left: ${this.#indentation}rem;` : '';
        }
    }

    get blockType() {
        return this.#blockType;
    }
    set blockType(value) {
        this.#blockType = value;
        this.#editor = this.#renderBlock();
    }
    get textAlign() {
        return this.#textAlign;
    }
    set textAlign(value) {
        this.#textAlign = value;
        this.#editor = this.#renderBlock();
    }
    //#endregion

    //#region constructor(parent, textBlock, setCurrentNode, setCurrentSelection)
    /**
     *
     * @param {HTMLDivElement} editor The parent editor element
     * @param {TextBlock} textBlock The TextBlock data
     * @param {(currentSelection) => void} setCurrentNode Used as a callback to set the currently focused node
     * @param {(currentSelection) => void} setCurrentSelection Used as a callback to set the currently focused selection
     */
    constructor(
        parent,
        textBlock = new TextBlock(),
        setCurrentNode = () => { },
        setCurrentSelection = () => { }
    ) {
        if (!parent) throw new Error('No parent element provided');

        this.#isMac = /Macintosh|Mac OS X/i.test(navigator.userAgent);

        // Render the editable block element inside the editor
        this.#blockType = textBlock.blockType;
        this.#indentation = textBlock.indentation;
        this.#textAlign = textBlock.textAlign;

        this.#content =
            textBlock.textNodes && textBlock.textNodes.length > 0
                ? textBlock.textNodes
                : EditableBlock.defaultContent;
        this.#setCurrentNode = setCurrentNode;
        this.#setCurrentSelection = setCurrentSelection;

        this.#editor = this.#renderBlock();

        //#region Event listeners
        this.#editor.addEventListener('keydown', this.#handleKeyDown.bind(this));
        this.#editor.addEventListener('keyup', this.#handleKeyUp.bind(this));
        this.#editor.addEventListener('input', this.#handleInput.bind(this));

        // Only change the currentSelection if the element is in focus. If something is clicked outside the element, keep it the same as it was before.
        this.#editor.addEventListener('focus', this.#handleFocus.bind(this));
        this.#editor.addEventListener('blur', this.#handleBlur.bind(this));

        document.addEventListener('selectionchange', this.#handleDocumentSelectionChange.bind(this));

        this.#observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (
                    mutation.type === 'childList' &&
                    (this.#editor.innerText.length < 1 ||
                        this.#editor.innerHTML === '<br>')
                ) {
                    this.#editor.innerHTML = '';
                    const element = document.createElement('span');
                    element.textContent = '\u200B';
                    this.#editor.appendChild(element);

                    CursorSelection.placeCursorAtIndex(this.#editor, 1);
                    this.parseContent();
                }
            }
        });

        this.#observer.observe(this.#editor, {
            childList: true,
        });
        //#endregion

        // Update the DOM to match the content
        this.updateDOM(this.#editor);
    }
    //#endregion

    //#region dispose()
    /**
     * Removes Event Listeners and DOM element
     */
    dispose() {
        this.#editor.addEventListener('keydown', this.#handleKeyDown.bind(this));
        this.#editor.addEventListener('keyup', this.#handleKeyUp.bind(this));
        this.#editor.addEventListener('input', this.#handleInput.bind(this));

        // Only change the currentSelection if the element is in focus. If something is clicked outside the element, keep it the same as it was before.
        this.#editor.addEventListener('focus', this.#handleFocus.bind(this));
        this.#editor.addEventListener('blur', this.#handleBlur.bind(this));

        document.addEventListener('selectionchange', this.#handleDocumentSelectionChange.bind(this));

        this.#observer.disconnect();

        this.#editor.remove();
    }
    //#endregion

    //#region setDisabled(isDisabled)
    setDisabled(isDisabled) {
        this.#editor.contentEditable = !isDisabled;
    }
    //#endregion

    //#region #renderBlock()
    /** @returns {HTMLElement} */
    #renderBlock() {
        let blockElement;

        switch (this.blockType) {
            case BlockTypes.typBody:
                blockElement = document.createElement('div');
                break;
            case BlockTypes.typHeading1:
                blockElement = document.createElement('h1');
                break;
            case BlockTypes.typHeading2:
                blockElement = document.createElement('h2');
                break;
            case BlockTypes.typHeading3:
                blockElement = document.createElement('h3');
                break;
            case BlockTypes.typBulletList:
                blockElement = document.createElement('div');
                blockElement.setAttribute('data-indentation', this.#indentation);
                blockElement.style =
                    this.#indentation > 0 ? `margin-left: ${this.#indentation}rem;` : '';
                break;
            case BlockTypes.typBlockQuote:
                blockElement = document.createElement('blockquote');
                break;
        }

        blockElement.contentEditable = true;
        blockElement.classList.add('text-block');
        if (this.blockType !== BlockTypes.typBulletList) {
            switch (this.#textAlign) {
                case AlignTypes.typLeft:
                    blockElement.style.textAlign = 'left';
                    break;
                case AlignTypes.typCenter:
                    blockElement.style.textAlign = 'center';
                    break;
                case AlignTypes.typRight:
                    blockElement.style.textAlign = 'right';
                    break;
            }
        }

        return blockElement;
    }
    //#endregion

    //#region updateDOM()
    /**
     * Updates the contenteditable div with the content array.
     * @param {HTMLElement} contentEditable The contenteditable element to update.
     */
    updateDOM() {
        this.#editor.innerHTML = '';
        this.#content.forEach(({ text, isBold, isUnderline, isItalic, link }) => {
            const element = document.createElement(link ? 'span' : 'span');
            element.textContent = text || ' ';
            if (isBold) element.classList.add('bold');
            if (isUnderline) element.classList.add('underline');
            if (isItalic) element.classList.add('italic');
            if (link) {
                element.setAttribute('href', link);
                element.onclick = (e) => {
                    if (e.ctrlKey) {
                        const newTab = window.open(link, '_blank');
                        if (newTab) {
                            newTab.focus();
                        }
                    }
                };
                element.title = 'Hold CTRL + click to view';
            }
            this.#editor.appendChild(element);
        });
    }
    //#endregion

    //#region parseContent()
    parseContent() {
        const nodes = Array.from(this.#editor.childNodes);

        this.#content = [];

        const processNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.textContent.trim()) {
                    this.#content.push({
                        text: node.textContent ? node.textContent : '\u200b',
                        isBold: false,
                        isUnderline: false,
                        isItalic: false,
                        link: null,
                    });
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const styles = {
                    isBold: node.classList.contains('bold'),
                    isUnderline: node.classList.contains('underline'),
                    isItalic: node.classList.contains('italic'),
                    link: node.getAttribute('href') || null,
                };

                this.#content.push({
                    text: node.textContent ? node.textContent : '\u200b',
                    ...styles,
                });
            }
        };

        nodes.forEach(processNode);
    }
    //#endregion

    //#region applyStyle(style, { link })
    /**
     * Applies a given style to the selected content in the contenteditable div.
     * @param {'bold' | 'underline' | 'italic' | 'link'} style The style to apply.
     * @param {Object} [options] Optional parameters, e.g., link URL.
     */
    applyStyle(style, options = { link: undefined }) {
        if (style === 'link' && !options.link) return; // Incase no link is given

        if (!this.currentSelection.insideSelection) {
            this.currentSelection = {};
        }

        // If range is collapsed, insert an empty styled node
        if (
            this.currentSelection?.startOffset === this.currentSelection?.endOffset
        ) {
            const [{ isBold, isUnderline, isItalic, link }] =
                this.currentSelection.insideSelection;

            if (
                this.currentSelection.beforeSelection.length > 0 &&
                this.currentSelection.beforeSelection[
                    this.currentSelection.beforeSelection.length - 1
                ].text === '\u200B'
            ) {
                this.currentSelection.beforeSelection.pop();
                this.currentSelection.startOffset -= 1;
                this.currentSelection.endOffset -= 1;
            }

            this.currentSelection.insideSelection = [
                {
                    text: '\u200B',
                    isBold: style === 'bold' ? !isBold : isBold,
                    isUnderline: style === 'underline' ? !isUnderline : isUnderline,
                    isItalic: style === 'italic' ? !isItalic : isItalic,
                    link: style === 'link' ? options.link || link : undefined,
                },
            ];
            this.currentSelection.startOffset += 1;
            this.currentSelection.endOffset += 1;
        } else {
            const selection = this.currentSelection?.insideSelection;
            if (!selection) return;
            const allBold = selection.reduce(
                (acc, node) => (node.isBold ? acc : node.isBold),
                true
            );
            const allUnderline = selection.reduce(
                (acc, node) => (node.isUnderline ? acc : node.isUnderline),
                true
            );
            const allItalic = selection.reduce(
                (acc, node) => (node.isItalic ? acc : node.isItalic),
                true
            );

            // Apply styles to all nodes in list
            for (const node of selection) {
                node.isBold = style === 'bold' ? !allBold : node.isBold;
                node.isUnderline =
                    style === 'underline' ? !allUnderline : node.isUnderline;
                node.isItalic = style === 'italic' ? !allItalic : node.isItalic;

                if (style === 'link') {
                    node.link = options.link;
                    node.isUnderline = true;
                }
            }
        }

        // Merge adjacent nodes
        this.#content = EditableBlock.mergeSimilarNodes([
            ...this.currentSelection.beforeSelection,
            ...this.currentSelection.insideSelection,
            ...this.currentSelection.afterSelection,
        ]);

        // Update global content and re-render DOM
        this.updateDOM();

        // Set cursor position at the end of the range
        CursorSelection.placeCursorAtIndex(
            this.#editor,
            this.currentSelection.startOffset,
            this.currentSelection.startOffset !== this.currentSelection.endOffset
                ? this.currentSelection.endOffset
                : undefined
        );
    }
    //#endregion

    //#region #handleFocus and #handleBlur
    #handleFocus() {
        this.#focusInsideEditor = true;
        this.#setCurrentNode(this);
        if (Object.entries(this.currentSelection).length < 1) {
            this.#handleSelectionChange();
        }

    }
    #handleBlur() {
        this.#focusInsideEditor = false;
    }
    //#endregion

    //#region #handleKeyDown(e)
    #handleKeyDown(e) {
        if (!this.#editor.contains(document.getSelection().anchorNode)) return;

        try {
            if (this.#isMac ? e.metaKey : e.ctrlKey) {
                switch (e.key.toLowerCase()) {
                    case 'b':
                        e.preventDefault();
                        this.applyStyle('bold');
                        break;
                    case 'u':
                        e.preventDefault();
                        this.applyStyle('underline');
                        break;
                    case 'i':
                        e.preventDefault();
                        this.applyStyle('italic');
                        break;
                }
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                this.#handleArrowKeys(e);
            } else if (e.key === 'Backspace') {
                this.#handleBackspace(e);
            }
        } catch (error) {
            console.error('Error in handleKeyDown:', error);
        }
    }

    #handleKeyUp() {
        try {
            if (!this.#editor.contains(document.getSelection().anchorNode)) return;
            // cleanupEmptyNodes();
            this.#content = EditableBlock.mergeSimilarNodes(this.#content);
        } catch (error) {
            console.error('Error in handleKeyUp:', error);
        }
    }
    //#endregion

    //#region #handleInput(e)
    #handleInput() {
        try {
            if (!this.#editor.contains(document.getSelection().anchorNode)) return;

            this.#removeZeroWidthSpaceOnType();
            this.parseContent();
        } catch (error) {
            console.error('Error in handleInput:', error);
        }
    }
    //#endregion

    //#region #handleArrowKeys(e)
    #handleArrowKeys(e) {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const node = range.startContainer;

        if (node.nodeType === Node.TEXT_NODE && node.textContent === '\u200B') {
            const parent = node.parentNode;
            if (e.key === 'ArrowLeft') {
                range.setStartBefore(parent);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                parent.remove();
            } else if (e.key === 'ArrowRight') {
                range.setStartAfter(parent);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                parent.remove();

                this.parseContent();
                // this.#content = EditableBlock.mergeSimilarNodes(this.#content);
                this.updateDOM();
                CursorSelection.placeCursorAtIndex(
                    this.#editor,
                    this.currentSelection.startOffset - 1
                );
            }
        }
    }
    //#endregion

    //#region #handleBackspace(e)
    #handleBackspace() {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const node = range.startContainer;

        if (
            node.nodeType === Node.TEXT_NODE &&
            node.textContent === '\u200B' &&
            range.startOffset === 1
        ) {
            const parent = node.parentNode;
            range.setStartBefore(parent);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            parent.remove();
        }

        this.#cleanEmptyNodes();
    }
    //#endregion

    //#region #cleanEmptyNodes()
    #cleanEmptyNodes() {
        this.#editor.querySelectorAll('span').forEach((span) => {
            if (span.textContent === '') span.remove();
        });
    }
    //#endregion

    //#region #removeZeroWidthSpaceOnType()
    #removeZeroWidthSpaceOnType() {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const node = range.startContainer;

        if (
            node.nodeType === Node.TEXT_NODE &&
            node.textContent.startsWith('\u200B')
        ) {
            const currentOffset = range.startOffset;
            const text = node.textContent;

            // Remove the zero-width space
            node.textContent = text.slice(1);

            // Position cursor after the typed character
            range.setStart(node, currentOffset - 1);
            range.setEnd(node, currentOffset - 1);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
    //#endregion

    //#region mergeSimilarNodes(array)
    /**
     * Merges adjacent nodes with similar styles.
     * @param {Array} array The content array to process.
     * @returns {Array} A merged array of nodes.
     */
    static mergeSimilarNodes(nodes) {
        return nodes.reduce((result, current) => {
            const last = result[result.length - 1];
            if (
                last &&
                last.isBold === current.isBold &&
                last.isUnderline === current.isUnderline &&
                last.isItalic === current.isItalic &&
                last.link === current.link
            ) {
                last.text += current.text;
            } else {
                result.push(current);
            }
            return result;
        }, []);
    }
    //#endregion

    //#region #handleSelectionChange()
    #handleDocumentSelectionChange() {
        if (this.#focusInsideEditor) this.#handleSelectionChange();

        if (
            this.currentSelection.startOffset === 0 &&
            this.#content.length === 1 &&
            this.#content[0].text === '\u200B'
        ) {
            CursorSelection.placeCursorAtIndex(this.#editor, 1);
            this.#handleSelectionChange();
        }
    }
    #handleSelectionChange() {
        const selection = window.getSelection();
        const range = CursorSelection.getCursorRangeInElement(this.#editor);

        if (selection.rangeCount > 0 && range) {
            let startOffset = range.startOffset,
                selectedRange = range.endOffset - range.startOffset;
            let beforeSelection = [],
                insideSelection = [],
                afterSelection = [];

            for (const node of this.#content) {
                if (startOffset > node.text.length) {
                    beforeSelection.push(node);

                    startOffset -= node.text.length;
                } else if (startOffset + selectedRange < node.text.length) {
                    if (startOffset > 0)
                        beforeSelection.push({
                            ...node,
                            text: node.text.slice(0, startOffset),
                        });
                    if (
                        startOffset + selectedRange > 0 ||
                        (startOffset + selectedRange === 0 && insideSelection.length === 0)
                    ) {
                        if (selectedRange === 0) {
                            // range is collapsed
                            const focusedNode = range.wrappingElement;
                            const selectedNode =
                                beforeSelection.length > 0 &&
                                    beforeSelection[beforeSelection.length - 1].text === '\u200B'
                                    ? beforeSelection[beforeSelection.length - 1]
                                    : {
                                        isBold: focusedNode.classList.contains('bold'),
                                        isUnderline: focusedNode.classList.contains('underline'),
                                        isItalic: focusedNode.classList.contains('italic'),
                                        link:
                                            focusedNode.tagName === 'A'
                                                ? focusedNode.href
                                                : undefined,
                                    };
                            insideSelection.push({
                                ...selectedNode,
                                text: '',
                            });
                        } else {
                            insideSelection.push({
                                ...node,
                                text: node.text.slice(startOffset, startOffset + selectedRange),
                            });
                        }
                    }
                    afterSelection.push({
                        ...node,
                        text: node.text.slice(startOffset + selectedRange),
                    });
                    startOffset = 0;
                    selectedRange = 0;
                } else if (startOffset + selectedRange >= node.text.length) {
                    if (startOffset > 0)
                        beforeSelection.push({
                            ...node,
                            text: node.text.slice(0, startOffset),
                        });
                    if (node.text.slice(startOffset) != '')
                        insideSelection.push({
                            ...node,
                            text: node.text.slice(startOffset),
                        });
                    selectedRange -= node.text.length - startOffset;
                    startOffset = 0;
                } else {
                    // This probably won't ever occur, as most of the time it will just hit the else if (startOffset + selectedRange < node.text.length) condition
                    afterSelection.push(node);
                }
            }

            if (insideSelection.length === 0 && beforeSelection.length > 0)
                insideSelection.push({
                    ...beforeSelection[beforeSelection.length - 1],
                    text: '',
                });

            this.currentSelection = {
                ...range,
                beforeSelection,
                insideSelection,
                afterSelection,
            };

            this.#setCurrentSelection(this.currentSelection);
        }
    }
    //#endregion
}

class RichTextInput {
    //#region Fields
    /** @type {HTMLDivElement} */
    #editorContent;
    /** @type {string} */
    #placeholder;
    /** @type {number} */
    #lastCursorOffsetX = 0;
    /** @type {EditableBlock?} */
    #focusedEditableBlock;
    /** @type {number} */
    #focusedEditableBlockIndex;
    /** @type {(block: EditableBlock?) => void} */
    onFocusedEditableBlockChange = (editableBlock) => { };
    /** @type {async (currentSelection: Object) => Promise} */
    onCurrentSelectionChange = (currentSelection) => { };
    /** @type {Array<EditableBlock | ImageBlock>} */
    #editableBlocks = [];
    /** @type {MutationObserver} */
    #attributeObserver;
    /** @type {boolean} */
    wasModified = false;
    //#endregion

    //#region Properties
    /** @type {Array<EditableBlock>} */
    get editableBlocks() {
        return this.#editableBlocks;
    }
    /** @type {Array<EditableBlock>} */
    set editableBlocks(value) {
        this.#editableBlocks.forEach((block) => block.dispose());
        this.#editableBlocks = value;
        this.#renderEditableBlocks();
    }
    get focusedBlock() {
        this.#renderEditableBlocks();
        return this.#focusedEditableBlock;
    }
    //#endregion

    //#region Constructor
    /**
     *
     * @param {HTMLDivElement} editor
     * @param {Array<EditableBlock>} content
     */
    constructor(editor, content = undefined) {
        this.#editorContent = editor.querySelector('.editor-content');
        this.#placeholder = editor.getAttribute('placeholder');

        if (!editor.hasAttribute('disabled')) {
            this.#editorContent.addEventListener(
                'keydown',
                this.#handleKeyDown.bind(this)
            );
            this.#editorContent.addEventListener(
                'mousedown',
                this.#handleMouseDown.bind(this)
            );

            this.#editorContent.addEventListener('paste', this.#handlePaste.bind(this));
            this.#editorContent.addEventListener('focusout', this.#handleFocusOut.bind(this));

            this.#editorContent.addEventListener('dragstart', this.#handleDragOver);
            this.#editorContent.addEventListener('dragover', this.#handleDragOver);
            this.#editorContent.addEventListener('dragenter', this.#handleDragOver);
            this.#editorContent.addEventListener('drop', this.#handleDragOver);
        }

        this.#attributeObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes') {
                    this.setDisabled(editor.hasAttribute('disabled'));
                }
            }
        })

        this.#attributeObserver.observe(editor, { attributes: true });

        this.setContent(content);
    }
    //#endregion

    //#region dispose
    dispose() {
        this.#attributeObserver.disconnect();

        this.#editorContent.removeEventListener(
            'keydown',
            this.#handleKeyDown.bind(this)
        );
        this.#editorContent.removeEventListener(
            'mousedown',
            this.#handleMouseDown.bind(this)
        );

        this.#editorContent.removeEventListener('paste', this.#handlePaste.bind(this));
        this.#editorContent.removeEventListener('focusout', this.#handleFocusOut.bind(this));

        this.#editorContent.removeEventListener('dragstart', this.#handleDragOver);
        this.#editorContent.removeEventListener('dragover', this.#handleDragOver);
        this.#editorContent.removeEventListener('dragenter', this.#handleDragOver);
        this.#editorContent.removeEventListener('drop', this.#handleDragOver);
    }
    //#endregion

    //#region getContent()
    /**
     *
     * @returns {Array<TextBlock | ImageBlock>}
     */
    getContent() {
        return this.editableBlocks.map((block) => {
            if (block.blockType === BlockTypes.typImage) {
                return { blockType: block.blockType, data: block?.data };
            } else {
                return new TextBlock(
                    block.blockType,
                    block?.indentation,
                    block?.textAlign,
                    block?.content,
                    block?.data
                );
            }
        });
    }
    //#endregion

    //#region setContent(content)
    /**
     *
     * @param {Array<TextBlock | ImageBlock>} content
     */
    setContent(content) {
        if (!content || content.length < 1) {
            this.editableBlocks = [];
            //this.#editorContent.innerHTML = '';

            const placeholder = document.createElement('div');
            placeholder.classList.add('placeholder');
            placeholder.classList.add('text-block');
            placeholder.textContent = this.#placeholder;
            this.#editorContent.appendChild(placeholder);
            return;
        }

        let cursorSelection;
        if (this.#focusedEditableBlock)
            cursorSelection = this.#focusedEditableBlock.currentSelection;

        this.editableBlocks = content.map((block) => {
            if (block.blockType === BlockTypes.typImage) {
                const imageBlock = new ImageBlock(
                    block.data,
                    this.#handleFocusedEditableBlockChanged.bind(this),
                    this.onCurrentSelectionChange
                );
                imageBlock.deleteButton.addEventListener('click', () => {
                    this.#deleteImageBlock(imageBlock);
                });

                return imageBlock;
            } else {
                return new EditableBlock(
                    this.#editorContent,
                    block,
                    this.#handleFocusedEditableBlockChanged.bind(this),
                    this.onCurrentSelectionChange
                );
            }
        });

        if (cursorSelection)
            CursorSelection.placeCursorAtIndex(
                this.#focusedEditableBlock.element,
                cursorSelection.startIndex,
                cursorSelection.endIndex
            );
    }
    //#endregion

    //#region setCurrentBlockType(blockType)
    /**
     *
     * @param {keyof typeof BlockTypes} blockType
     */
    setCurrentBlockType(blockType) {
        const previousSelection = this.#focusedEditableBlock?.currentSelection;

        const content = this.getContent();
        content[this.#focusedEditableBlockIndex || 0] = new TextBlock(
            blockType,
            this.#focusedEditableBlock?.indentation || 0,
            this.#focusedEditableBlock?.textAlign || AlignTypes.left,
            this.editableBlocks[this.#focusedEditableBlockIndex || 0]?.content
        );

        this.setContent(content);

        this.editableBlocks = this.#editableBlocks;

        this.#focusedEditableBlock =
            this.editableBlocks[this.#focusedEditableBlockIndex || 0];

        this.#focusedEditableBlock.element.focus();
        CursorSelection.placeCursorAtIndex(
            this.#focusedEditableBlock.element,
            previousSelection?.startOffset || 0,
            previousSelection?.endOffset
        );
    }
    //#endregion

    //#region setCurrentAlignType(textAlignType)
    /**
     *
     * @param {keyof typeof AlignTypes} textAlignType
     */
    setCurrentAlignType(textAlignType) {
        const previousSelection = this.#focusedEditableBlock?.currentSelection;

        const content = this.getContent();
        content[this.#focusedEditableBlockIndex || 0] = new TextBlock(
            this.#focusedEditableBlock?.blockType || BlockTypes.typBody,
            this.#focusedEditableBlock?.indentation || 0,
            textAlignType,
            this.editableBlocks[this.#focusedEditableBlockIndex || 0]?.content
        );

        this.setContent(content);

        this.#focusedEditableBlock =
            this.editableBlocks[this.#focusedEditableBlockIndex || 0];

        this.#focusedEditableBlock.element.focus();
        CursorSelection.placeCursorAtIndex(
            this.#focusedEditableBlock.element,
            previousSelection?.startOffset || 0,
            previousSelection?.endOffset
        );
    }
    //#endregion

    //#region applyStyle(style)
    /**
     *
     * @param {'bold' | 'underline' | 'italic' | 'link'} style
     * @param {string?} link
     */
    applyStyle(style, link) {
        this.editableBlocks[this.#focusedEditableBlockIndex].element.focus();
        this.editableBlocks[this.#focusedEditableBlockIndex].applyStyle(style, {
            link,
        });
    }
    //#endregion

    //#region insertImage(image)
    /**
     *
     * @param {ImageBlockData} imageData
     */
    insertImage(imageData = new ImageBlockData()) {
        if (!imageData.src || imageData.src === '') {
            throw new Error('Invalid image source provided');
        }
        const insertAtIndex = this.#focusedEditableBlockIndex + 1;
        const currentContent = this.getContent();

        if (this.getContent().length === 0) {
            this.setContent([
                new ImageBlock(imageData),
                new TextBlock(BlockTypes.typBody),
            ]);
        } else {
            this.setContent([
                ...currentContent.slice(0, insertAtIndex),
                new ImageBlock(imageData),
                ...currentContent.slice(insertAtIndex),
            ]);
        }

        this.#focusedEditableBlock = undefined;
        this.onFocusedEditableBlockChange(this.#focusedEditableBlock);
    }
    //#endregion

    //#region setDisabled(isDisabled)
    setDisabled(isDisabled) {
        // Cleared listeners for good measure
        this.#editorContent.removeEventListener(
            'keydown',
            this.#handleKeyDown.bind(this)
        );
        this.#editorContent.removeEventListener(
            'mousedown',
            this.#handleMouseDown.bind(this)
        );

        this.#editorContent.removeEventListener('paste', this.#handlePaste.bind(this));
        this.#editorContent.removeEventListener('focusout', this.#handleFocusOut.bind(this));

        this.#editorContent.removeEventListener('dragstart', this.#handleDragOver);
        this.#editorContent.removeEventListener('dragover', this.#handleDragOver);
        this.#editorContent.removeEventListener('dragenter', this.#handleDragOver);
        this.#editorContent.removeEventListener('drop', this.#handleDragOver);

        // Re-initialize listeners if not disabled
        if (!isDisabled) {
            this.#editorContent.addEventListener(
                'keydown',
                this.#handleKeyDown.bind(this)
            );
            this.#editorContent.addEventListener(
                'mousedown',
                this.#handleMouseDown.bind(this)
            );

            this.#editorContent.addEventListener('paste', this.#handlePaste.bind(this));
            this.#editorContent.addEventListener('focusout', this.#handleFocusOut.bind(this));

            this.#editorContent.addEventListener('dragstart', this.#handleDragOver);
            this.#editorContent.addEventListener('dragover', this.#handleDragOver);
            this.#editorContent.addEventListener('dragenter', this.#handleDragOver);
            this.#editorContent.addEventListener('drop', this.#handleDragOver);
        }

        this.#editableBlocks.map((block) => {
            block.setDisabled(isDisabled);
        })
    }
    //#endregion

    //#region #handleFocusedEditableBlockChanged(focusedBlock)
    /**
     *
     * @param {EditableBlock?} focusedBlock
     */
    #handleFocusedEditableBlockChanged(focusedBlock = null) {
        this.#focusedEditableBlock = focusedBlock;
        if (this.#focusedEditableBlock)
            this.#focusedEditableBlockIndex =
                this.editableBlocks.indexOf(focusedBlock);
        else this.#focusedEditableBlockIndex = 0;
        this.onFocusedEditableBlockChange(focusedBlock);
    }
    //#endregion

    //#region #handleFocusOut
    #handleFocusOut() {
        // Using setTimeout to ensure the next focused element can be evaluated
        setTimeout(() => {
            if (!this.#editorContent.contains(document.activeElement)) {
                if (
                    this.getContent()[0]?.textNodes?.length === 1 &&
                    this.getContent()[0]?.textNodes?.[0]?.text === '\u200B' &&
                    this.getContent()[0]?.blockType === BlockTypes.typBody &&
                    this.getContent()[0]?.blockType !== BlockTypes.typImage
                ) {
                    this.setContent([]);
                }
            }
        }, 0);
    }
    //#endregion

    //#region #renderEditableBlocks()
    #renderEditableBlocks() {
        this.#editorContent.innerHTML = ''; // Clear the other content and re-render the new text blocks

        this.editableBlocks.forEach((block) => {
            this.#editorContent.appendChild(block.element);
        });
    }
    //#endregion

    //#region #handleKeyDown(e)
    #handleKeyDown(e) {
        if (!this.#focusedEditableBlock) return;

        const currentSelection = this.#focusedEditableBlock?.currentSelection;
        const currentBlockRef = this.#focusedEditableBlock?.element;

        // If anything other than up and down arrows are pressed
        if (
            e.key.toLowerCase() !== 'arrowup' &&
            e.key.toLowerCase() !== 'arrowdown'
        ) {
            this.#lastCursorOffsetX = 0;
        }

        switch (e.key.toLowerCase()) {
            case 'enter': {
                e.preventDefault();

                if (
                    this.#focusedEditableBlock.blockType === BlockTypes.typBulletList &&
                    this.#focusedEditableBlock.content.length === 1 &&
                    this.#focusedEditableBlock.content.at(0).text === '\u200B'
                ) {
                    this.#editableBlocks[this.#focusedEditableBlockIndex].indentation = 0;
                    this.setCurrentBlockType(BlockTypes.typBody);
                    break;
                }

                const { beforeSelection, afterSelection } =
                    this.#focusedEditableBlock.currentSelection;

                const newContent = [...this.getContent()];

                newContent.splice(
                    this.#focusedEditableBlockIndex,
                    1,
                    ...[
                        new TextBlock(
                            this.#focusedEditableBlock.blockType,
                            this.#focusedEditableBlock.indentation,
                            this.#focusedEditableBlock.textAlign,
                            beforeSelection
                        ),
                        new TextBlock(
                            this.#focusedEditableBlock.blockType === BlockTypes.typBulletList
                                ? this.#focusedEditableBlock.blockType
                                : BlockTypes.typBody,
                            this.#focusedEditableBlock.indentation,
                            AlignTypes.typLeft, // Alternatively this.#focusedEditableBlock.textAlign to maintain the previous lines text alignment
                            afterSelection
                        ),
                    ]
                );

                this.setContent(newContent);

                CursorSelection.placeCursorAtIndex(
                    this.editableBlocks.at(this.#focusedEditableBlockIndex + 1).element,
                    0
                );

                break;
            }
            case 'delete':
            case 'backspace': {
                const isDeleteAtLast =
                    e.key.toLowerCase() === 'delete' &&
                    currentSelection.endOffset == currentBlockRef?.innerText.length;
                const isBackspaceAtFirst =
                    e.key.toLowerCase() === 'backspace' &&
                    (currentSelection.startOffset === 0 ||
                        (currentBlockRef.innerText === '\u200b' &&
                            currentSelection.startOffset === 1));
                if (
                    currentSelection &&
                    currentSelection.startOffset === currentSelection.endOffset &&
                    (isDeleteAtLast || isBackspaceAtFirst)
                ) {
                    e.preventDefault();

                    let targetIndex =
                        this.#focusedEditableBlockIndex +
                        (e.key.toLowerCase() === 'delete' ? 1 : -1);
                    let adjacentEditableBlock = this.editableBlocks[targetIndex];
                    while (adjacentEditableBlock?.blockType === BlockTypes.typImage) {
                        targetIndex += e.key.toLowerCase() === 'delete' ? 1 : -1;
                        adjacentEditableBlock = this.editableBlocks[targetIndex];
                    }

                    if (
                        isBackspaceAtFirst &&
                        this.#focusedEditableBlock.blockType === BlockTypes.typBulletList
                    ) {
                        // If the block is indented and has a adjacent block with lower indentation,
                        // decrease the indentation before merging with the adjacent block
                        if (
                            (adjacentEditableBlock &&
                                adjacentEditableBlock?.blockType !==
                                BlockTypes.typBulletList) ||
                            (this.#focusedEditableBlock.indentation > 0 &&
                                adjacentEditableBlock.indentation <
                                this.#focusedEditableBlock.indentation)
                        ) {
                            for (
                                let i = this.#focusedEditableBlockIndex + 1;
                                i < this.editableBlocks.length;
                                i++
                            ) {
                                if (
                                    this.editableBlocks[i].blockType ===
                                    BlockTypes.typBulletList &&
                                    this.editableBlocks[i].indentation >
                                    this.#focusedEditableBlock.indentation
                                ) {
                                    this.editableBlocks[i].indentation -= 1;
                                } else {
                                    break;
                                }
                            }

                            if (
                                this.#focusedEditableBlock.indentation > 0 &&
                                adjacentEditableBlock.indentation <
                                this.#focusedEditableBlock.indentation
                            ) {
                                this.editableBlocks[
                                    this.#focusedEditableBlockIndex
                                ].indentation -= 1;
                                break;
                            }
                        } else {
                            this.setCurrentBlockType(BlockTypes.typBody);
                            break;
                        }
                    } else if (
                        isBackspaceAtFirst &&
                        this.#focusedEditableBlock.textAlign !== AlignTypes.typLeft
                    ) {
                        this.setCurrentAlignType(AlignTypes.typLeft);
                        break;
                    }

                    if (adjacentEditableBlock) {
                        const [startIndex, endIndex] =
                            targetIndex > this.#focusedEditableBlockIndex
                                ? [this.#focusedEditableBlockIndex, targetIndex]
                                : [targetIndex, this.#focusedEditableBlockIndex];

                        const [startBlock, endBlock] = [
                            this.editableBlocks[startIndex],
                            this.editableBlocks[endIndex],
                        ];

                        const content = this.getContent();
                        content[startIndex] = new TextBlock(
                            startBlock.blockType,
                            startBlock.indentation,
                            startBlock.textAlign,
                            [
                                ...startBlock.content,
                                ...endBlock.content.map((textNode) => {
                                    textNode.text = textNode.text.replace('\u200b', '');
                                    return textNode;
                                }),
                            ]
                        );

                        content.splice(endIndex, 1);

                        this.setContent(content);

                        CursorSelection.placeCursorAtIndex(
                            this.editableBlocks[startIndex].element,
                            startBlock.element.innerText.length
                        );
                    } else {
                        //const content = this.getContent();
                        //content.splice(this.#focusedEditableBlockIndex, 1)
                        //this.setContent(content);
                    }
                }
                break;
            }
            case 'arrowleft':
            case 'arrowright': {
                if (
                    currentSelection &&
                    currentSelection.startOffset === currentSelection.endOffset &&
                    ((e.key.toLowerCase() === 'arrowright' &&
                        currentSelection.endOffset == currentBlockRef?.innerText.length) ||
                        (e.key.toLowerCase() === 'arrowleft' &&
                            (currentSelection.startOffset === 0 ||
                                (currentBlockRef.innerText === '\u200b' &&
                                    currentSelection.startOffset === 1))))
                ) {
                    e.preventDefault();

                    let targetIndex =
                        this.#focusedEditableBlockIndex +
                        (e.key.toLowerCase() === 'arrowright' ? 1 : -1);
                    let adjacentEditableBlock = this.editableBlocks[targetIndex];
                    if (!adjacentEditableBlock) break;
                    while (adjacentEditableBlock?.blockType === BlockTypes.typImage) {
                        targetIndex += e.key.toLowerCase() === 'arrowright' ? 1 : -1;
                        adjacentEditableBlock = this.editableBlocks[targetIndex];
                    }

                    if (e.key.toLowerCase() === 'arrowright' && !adjacentEditableBlock) {
                        // Add a new text block
                        const currentContent = this.getContent();
                        currentContent.push(new TextBlock(BlockTypes.typBody));
                        this.setContent(currentContent);

                        adjacentEditableBlock = this.editableBlocks.at(-1);
                    }

                    if (adjacentEditableBlock) {
                        CursorSelection.placeCursorAtIndex(
                            adjacentEditableBlock.element,
                            e.key.toLowerCase() === 'arrowright'
                                ? 0
                                : adjacentEditableBlock.element.innerText.length
                        );
                    }
                }
                break;
            }
            case 'arrowup':
            case 'arrowdown': {
                // Check if cursor is at the last or first line (depending on the key press);
                const focusedLine = this.#checkFocusedLine(
                    currentBlockRef,
                    e.key.toLowerCase() === 'arrowdown'
                );

                if (
                    focusedLine &&
                    ((focusedLine === 'first' && e.key.toLowerCase() === 'arrowup') ||
                        (focusedLine === 'last' && e.key.toLowerCase() === 'arrowdown'))
                ) {
                    e.preventDefault();

                    let targetIndex =
                        this.#focusedEditableBlockIndex +
                        (e.key.toLowerCase() === 'arrowdown' ? 1 : -1);
                    let adjacentEditableBlock = this.editableBlocks[targetIndex];
                    if (!adjacentEditableBlock) break;
                    while (adjacentEditableBlock?.blockType === BlockTypes.typImage) {
                        targetIndex += e.key.toLowerCase() === 'arrowdown' ? 1 : -1;
                        adjacentEditableBlock = this.editableBlocks[targetIndex];
                    }

                    if (e.key.toLowerCase() === 'arrowdown' && !adjacentEditableBlock) {
                        // Add a new text block
                        const currentContent = this.getContent();
                        currentContent.push(new TextBlock(BlockTypes.typBody));
                        this.setContent(currentContent);

                        adjacentEditableBlock = this.editableBlocks.at(-1);
                    }

                    if (adjacentEditableBlock) {
                        this.#moveCaretToNewLine(
                            adjacentEditableBlock,
                            e.key.toLowerCase() === 'arrowdown'
                        );
                    }
                }
                break;
            }
            case 'tab': {
                e.preventDefault();

                if (e.shiftKey) {
                    if (this.#focusedEditableBlock.indentation > 0) {
                        for (
                            let i = this.#focusedEditableBlockIndex + 1;
                            i < this.editableBlocks.length;
                            i++
                        ) {
                            if (
                                this.editableBlocks[i].blockType === BlockTypes.typBulletList &&
                                this.editableBlocks[i].indentation >
                                this.#focusedEditableBlock.indentation
                            ) {
                                this.editableBlocks[i].indentation -= 1;
                            } else {
                                break;
                            }
                        }

                        this.editableBlocks[
                            this.#focusedEditableBlockIndex
                        ].indentation -= 1;
                    }
                } else {
                    // Indent the block if a parent block with greater indention is found
                    let parentBlock = undefined;
                    let currentIndex = this.#focusedEditableBlockIndex - 1;
                    // Traverse till a block with less indention is found, else return undefined
                    while (!parentBlock && currentIndex >= 0) {
                        const currentBlock = this.editableBlocks[currentIndex];

                        if (
                            currentBlock.indentation ===
                            this.#focusedEditableBlock.indentation
                        ) {
                            parentBlock = currentBlock;
                        } else {
                            currentIndex--;
                        }
                    }

                    if (parentBlock) {
                        for (
                            let i = this.#focusedEditableBlockIndex + 1;
                            i < this.editableBlocks.length;
                            i++
                        ) {
                            const childBlock = this.editableBlocks[i];

                            if (
                                childBlock.blockType === BlockTypes.typBulletList &&
                                childBlock.indentation > this.#focusedEditableBlock.indentation
                            ) {
                                this.editableBlocks[i].indentation += 1;
                            } else {
                                break;
                            }
                        }

                        this.editableBlocks[
                            this.#focusedEditableBlockIndex
                        ].indentation += 1;
                    }
                }
                break;
            }
            // Space key
            case ' ': {
                // Check if the contents of the focused block is a '-'
                if (
                    this.#focusedEditableBlock.blockType !== BlockTypes.typBulletList &&
                    this.#focusedEditableBlock.element.innerText.startsWith('-')
                ) {
                    e.preventDefault();
                    const currentContent = this.getContent();
                    currentContent.at(this.#focusedEditableBlockIndex).textNodes[0].text =
                        currentContent
                            .at(this.#focusedEditableBlockIndex)
                            .textNodes[0].text.slice(1);
                    this.setContent(currentContent);

                    this.setCurrentBlockType(BlockTypes.typBulletList);
                    CursorSelection.placeCursorAtIndex(
                        this.#focusedEditableBlock.element,
                        0
                    );
                }
                break;
            }
        }
    }
    //#endregion

    //#region #handleMouseDown(e)
    #handleMouseDown(e) {
        if (this.getContent().length < 1 || this.getContent().reduce((acc, block) => {
            acc.isAllImages = block.blockType == BlockTypes.typImage;
            return acc;
        }, { isAllImages: true }).isAllImages) {
            if (e.target.closest('.image-block')) return;

            e.preventDefault();
            this.setContent([...this.getContent(), new TextBlock(BlockTypes.typBody)]);

            this.editableBlocks[this.editableBlocks.length - 1]?.element.focus();
            CursorSelection.placeCursorAtIndex(this.editableBlocks[0].element, 0);
            return;
        }

        // Clears it if mouse clicks or key press
        this.#lastCursorOffsetX = 0;

        // If the editor was clicked but not a text__block element, focus on the closes text block. This will allow for padding and such in the editor
        const target =
            e.target.closest('.text-block') || e.target.closest('.image-block');
        if (target) {
            return;
        }

        // If not inside a text__block, find the one where click.y is within bounds
        let editableBlocks = Array.from(
            this.#editorContent.querySelectorAll('.text-block')
        );
        if (editableBlocks.length < 1) {
            this.setContent([new TextBlock(BlockTypes.typBody)]);
        }

        const clickY = e.clientY;
        let targetEditableBlockRef = null;
        for (const block of editableBlocks) {
            const rect = block.getBoundingClientRect();
            if (clickY >= rect.top && clickY <= rect.bottom) {
                targetEditableBlockRef = block;
                break;
            }
        }

        if (targetEditableBlockRef) {
            const targetTextRect = this.#getTextBoundingRect(targetEditableBlockRef);
            targetEditableBlockRef.focus();
            if (targetEditableBlockRef.getBoundingClientRect().left > e.clientX) {
                this.#moveCaretToPixelX(
                    targetEditableBlockRef,
                    targetTextRect.left,
                    e.clientY
                );
            } else {
                this.#moveCaretToPixelX(
                    targetEditableBlockRef,
                    targetTextRect.right,
                    e.clientY
                );
            }
            e.preventDefault();
        } else {
            let targetTextRect = editableBlocks.at(0)?.getBoundingClientRect();
            let targetX;
            if (targetTextRect.left > e.clientX) targetX = targetTextRect.left;
            else if (targetTextRect.right < e.clientX)
                targetX = Math.floor(targetTextRect.right);
            // .floor puts pixel position just inside of element
            else targetX = e.clientX;

            if (targetTextRect.top > e.clientY) {
                this.#moveCaretToPixelX(
                    editableBlocks.at(0),
                    targetX,
                    targetTextRect.top
                );
            } else {
                if (this.#editableBlocks.at(-1)?.blockType === BlockTypes.typImage) {
                    // Add a new text block
                    const currentContent = this.getContent();
                    currentContent.push(new TextBlock(BlockTypes.typBody));
                    this.setContent(currentContent);
                    editableBlocks = Array.from(
                        this.#editorContent.querySelectorAll('.text-block')
                    );
                }
                targetTextRect = editableBlocks.at(-1).getBoundingClientRect();

                this.#moveCaretToPixelX(
                    editableBlocks.at(0),
                    targetX,
                    Math.floor(targetTextRect.bottom)
                );
            }
            e.preventDefault();
        }
    }
    //#endregion

    //#region #handleDragOver
    #handleDragOver(e) {
        e.preventDefault();
    }
    //#endregion

    //#region #handlePaste(e)
    #handlePaste(e) {
        e.preventDefault();

        const currentContent = this.getContent();

        console.log(e.clipboardData);

        let text = e.clipboardData.getData('text/plain');

        if (!text) {
            text = e.clipboardData.getData('text/html');

            const div = document.createElement('div');
            div.innerHTML = text;

            text = div.innerText;
            text.replace(/(\r\n|\n|\r)/g, ' ');
        }

        currentContent.push(
            new TextBlock(BlockTypes.typBody, 0, AlignTypes.typLeft, [
                new TextNode(text, {
                    isBold: false,
                    isItalic: false,
                    isUnderline: false,
                    link: undefined,
                }),
            ])
        );

        this.setContent(currentContent);

        CursorSelection.placeCursorAtIndex(
            this.editableBlocks.at(-1).element,
            this.editableBlocks.at(-1).element.innerText.length
        );
    }
    //#endregion

    //#region #deleteImageBlock(imageBlock)
    /**
     *
     * @param {ImageBlock} imageBlock
     */
    #deleteImageBlock(imageBlock) {
        const indexOfBlock = this.#editableBlocks.indexOf(imageBlock);

        this.editableBlocks = [
            ...this.#editableBlocks.slice(0, indexOfBlock),
            ...this.#editableBlocks.slice(indexOfBlock + 1),
        ];

        imageBlock.dispose();

        this.#editableBlocks.at(indexOfBlock)?.element.focus();
    }
    //#endregion

    //#region #checkFocusedLine(nodeRef, checkLast = false)
    /**
     * Check if the cursor is at the start or end of the focused line
     * @param {HTMLElement} nodeRef
     * @param {boolean} checkLast
     * @returns {'first' | 'last' | null}
     */
    #checkFocusedLine(nodeRef, checkLast = false) {
        const selection = window.getSelection();
        if (!selection.rangeCount) return null;

        const range = selection.getRangeAt(0);
        const caretRect = range.getBoundingClientRect();
        const currentNodeRect = this.#getTextBoundingRect(nodeRef);

        if (!checkLast) {
            return caretRect.top === 0 || caretRect.top === currentNodeRect?.top
                ? 'first'
                : null;
        } else {
            return caretRect.bottom === 0 ||
                caretRect.bottom === currentNodeRect?.bottom
                ? 'last'
                : null;
        }
    }
    //#endregion

    //#region #getTextBoundingRect(nodeRef)
    /**
     * Get the bounding rect of the text node
     * @param {HTMLElement} nodeRef
     * @returns {DOMRect}
     */
    #getTextBoundingRect(nodeRef) {
        if (!nodeRef) {
            return null;
        }

        if (!nodeRef.firstChild) {
            const textNode = document.createTextNode('');
            nodeRef.appendChild(textNode);
        }

        const range = document.createRange();

        range.selectNodeContents(nodeRef);

        const rect = range.getBoundingClientRect();

        range.detach?.(); // Avoid memory leaks (in older browsers)

        return rect;
    }
    //#endregion

    //#region #moveCaretToPixelX(targetElementRef, x, y)
    /**
     * Move the caret to a specific pixel X position on the target element.
     * Used for placing the caret at the top or bottom of the element.
     * @param {HTMLElement} targetElementRef
     * @param {number} x
     * @param {number} y
     */
    #moveCaretToPixelX(targetElementRef, x, y) {
        const selection = window.getSelection();

        // If there is only one empty text node in the element, place the caret at the start of the element.
        if (
            Array.from(targetElementRef.childNodes).length == 1 &&
            targetElementRef.childNodes[0]?.textContent == ''
        ) {
            const newRange = document.createRange();
            newRange.setStartBefore(targetElementRef.firstChild);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            return;
        }

        // Using `caretPositionFromPoint` to place the caret relative to the target element.
        const caretPosition = document.caretPositionFromPoint(x, y);

        // If the caret position is valid, place the caret at that position.
        if (caretPosition) {
            const newRange = document.createRange();
            newRange.setStart(caretPosition.offsetNode, caretPosition.offset);
            newRange.setEnd(caretPosition.offsetNode, caretPosition.offset);
            selection.removeAllRanges();
            selection.addRange(newRange);
        } else {
            // If the caret position is invalid, place the caret at the end of the element.
            const newRange = document.createRange();
            newRange.setStartAfter(targetElementRef.lastChild);

            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    }
    //#endregion

    //#region #moveCaretToNewLine(targetElementId, atFirstLine)
    /**
     * Moves the caret to a new line in the specified target element.
     * @param {EditableBlock} targetEditableBlock - The ID of the target element where the caret should move.
     * @param {boolean} atFirstLine - If true, move the caret to the first line; otherwise, move it to the last line.
     */
    #moveCaretToNewLine(targetEditableBlock, atFirstLine) {
        const targetElementRef = targetEditableBlock.element;
        if (!targetElementRef) {
            console.error('Target element not found');
            return;
        }

        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        const caretRect = range.getBoundingClientRect();

        // Calculate the current x position of the caret relative to the left of the editorRef
        let caretX = caretRect.left;
        if (this.#lastCursorOffsetX !== 0) caretX = this.#lastCursorOffsetX;
        else this.#lastCursorOffsetX = caretX;

        // Determine the target Y position based on atFirstLine flag
        const targetRect = this.#getTextBoundingRect(targetElementRef);
        let targetY = atFirstLine ? targetRect?.top : targetRect?.bottom;

        // Move caret to the calculated pixel position within the target element
        this.#moveCaretToPixelX(
            targetElementRef,
            caretX !== 0 ? caretX : targetRect.left,
            targetY
        );
    }
    //#endregion
}

if (!window.textEditors) window.textEditors = new Map();
if (!window.DotNets) window.DotNets = new Map();

// !
const editorRef = params[0];
const initialContent = params[1];
const DotNet = params[2];
// !

    let richTextInput = undefined;

    if (window.textEditors.has(editorRef?.id)) {
        richTextInput = window.textEditors.get(editorRef?.id);
    } else {
        richTextInput = new RichTextInput(editorRef, JSON.parse(initialContent));
        window.textEditors.set(editorRef?.id, richTextInput);
    }

    window.DotNets.set(editorRef?.id, DotNet);

    const blockTypeDropdown = editorRef.querySelector('.block-type-select');

    richTextInput.onFocusedEditableBlockChange = (focusedBlock) => {
        // Update the current selected block type
        blockTypeDropdown.value = focusedBlock?.blockType || BlockTypes.typImage;
        blockTypeDropdown.disabled = !focusedBlock;
    };

    richTextInput.onCurrentSelectionChange = async (currentSelection) => {
        if (!richTextInput.wasModified) {
            // Content was selected inside the rich text editor
            // Prevent Blazor from causing mix-up's in the DOM
            await window.DotNets.get(editorRef?.id)?.invokeMethodAsync('subHandleCurrentSelectionChange');
            // Prevent DotNet method from being called everytime selection changes
            richTextInput.wasModified = true;
        }

        const { isBold, isUnderline, isItalic, link } =
            currentSelection.insideSelection.reduce(
                (acc, node) => {
                    if (node.isBold) acc.isBold = true;
                    if (node.isUnderline) acc.isUnderline = true;
                    if (node.isItalic) acc.isItalic = true;
                    if (!acc.link || node.link === acc.link) {
                        acc.link = node.link;
                    } else if (node.link && acc.link && node.link !== acc.link) {
                        // If both links aren't null and they don't match, link will be null as there are multiple different links
                        acc.link = null;
                    }

                    return acc;
                },
                {
                    isBold: false,
                    isUnderline: false,
                    isItalic: false,
                    link: null
                }
            );

        // Update the style buttons based on the current selection
        editorRef
            .querySelectorAll('.editor-control-bar__style-button')
            .forEach((button) => {
                if (
                    (button.id === 'bold' && isBold) ||
                    (button.id === 'underline' && isUnderline) ||
                    (button.id === 'italic' && isItalic) ||
                    (button.id === 'link' && link)
                ) {
                    button.classList.add('active');
                    if (button.id === 'link') button.setAttribute('data-link', link);
                } else {
                    button.classList.remove('active');
                    if (button.id === 'link') button.removeAttribute('data-link');
                }
            });
    };

    // Send JSON to Blazor to store when focus leaves
    const handleFocusOut = (e) => {
        const content = richTextInput.getContent();

        // Prevent image data from being transferred back
        const result = content.map((block) => {
            const blockCopy = JSON.parse(JSON.stringify(block));
            if (blockCopy.data?.src) blockCopy.data.src = '';

            return blockCopy;
        });

        DotNet.invokeMethodAsync('subSetValue', JSON.stringify(result));
    };
    editorRef.addEventListener('focusout', handleFocusOut)

    let initialContentSet = false;

    return {
        //getContent: () => {
        //    const content = richTextInput.getContent();

        //    content = content.map((block) => {
        //        if (block.data?.src) block.data.src = '';

        //        return block;
        //    })

        //    console.log(content);

        //    return JSON.stringify(content);
        //},
        /**
         * Set's rich text editors content
         * @param {string} newContentJson
         */
        setContent: (newContentJson) => {
            const newContentNormalizedJson = JSON.stringify(JSON.parse(newContentJson), (key, value) => {
                return value === null ? undefined : value;
            });
            const currentContentJson = JSON.stringify(richTextInput.getContent(), (key, value) => {
                return value === null ? undefined : value;
            });
            if (!initialContentSet || (newContentNormalizedJson != currentContentJson && newContentNormalizedJson)) {
                initialContentSet = true;
                richTextInput.setContent(JSON.parse(newContentJson));
            }
        },
        /**
         * @param {'bold' | 'underline' | 'italic' | 'link'} type
         * @param {string?} link
         */
        applyStyle: (type, link = undefined) => {
            richTextInput.applyStyle(type, link);
        },
        /** @param {keyof typeof AlignTypes} type */
        setTextAlign: (type) => {
            richTextInput.setCurrentAlignType(type);
        },
        /** @param {keyof typeof BlockTypes} type */
        setBlockType: (type) => {
            richTextInput.setCurrentBlockType(type);
        },
        /**
         * @params {string} imageBase64
         * @params {string} imageId
         */
        insertImage: (imageBase64, imageId) => {
            return richTextInput.insertImage(
                new ImageBlockData(imageBase64, imageId)
            );
        },
        setDisabled: (isDisabled) => {
            richTextInput.setDisabled(isDisabled);
        },
        dispose: () => {
            editorRef.removeEventListener('focusout', handleFocusOut);
            richTextInput.dispose();
            window.textEditors.delete(editorRef?.id);
            window.DotNets.delete(editorRef?.id);
        }
    }
";

            mobjJSRichTextEditor = await mobjJSRuntime.InvokeAsync<Microsoft.JSInterop.IJSObjectReference>("js", strJSScript, fobjEditorRef, strJSONCurrentValue, Microsoft.JSInterop.DotNetObjectReference.Create(this));
        }

        await mobjJSRichTextEditor.InvokeVoidAsync("setContent", strJSONCurrentValue);

        // Add images
        for (System.Int32 i = 0; i < (mobjCurrentValue?.Count ?? 0); i++)
        {
            if (mobjCurrentValue?.ElementAtOrDefault(i)?.menmBlockType == Classes.enumBlockType.typImage)
            {
                if (mdictImages.ContainsKey(mobjCurrentValue?.ElementAtOrDefault(i)?.mobjImageData?.mstrImageId ?? ""))
                {
                    mdictImages[mobjCurrentValue[i].mobjImageData.mstrImageId] = mobjCurrentValue[i].mobjImageData.mstrSrc.Split("base64,")[1];
                }
                else
                {
                    mdictImages.Add(mobjCurrentValue[i].mobjImageData.mstrImageId, mobjCurrentValue[i].mobjImageData.mstrSrc.Split("base64,")[1]);
                }
            }
        }
    }
    #endregion

    #region subHandleCurrentSelectionChange
    [JSInvokable("subHandleCurrentSelectionChange")]
    public void subHandleCurrentSelectionChange()
    {
        // Set Content Changed to *true*
        // This prevents Blazor from detecting the change to the DOM on a new line, or delete line action.
        // Letting this component know whether to sync the content from OnAfterRenderAsync or not. 
        // After an input is made, OnAfterRender should not sync content again
        mblnContentChanged = true;
    }
    #endregion

    #region subHandleImageInsert
    private async void subHandleImageInsert()
    {
        if (prpIsDisabled) return;

        try
        {
            if (mobjJSRichTextEditor == null || fobjImageModalRef == null) return;

            Modal.enumCloseAction enmCloseAction = await fobjImageModalRef.fncShowModal();

            if (enmCloseAction != Modal.enumCloseAction.typConfirm)
            {
                return;
            }

            if (falobjImage == null || falobjImage.Count == 0)
            {
                throw new System.Exception("Please provide a valid image");
            }

            Microsoft.AspNetCore.Components.Forms.IBrowserFile? objImage = await falobjImage.First().mobjFile.RequestImageFileAsync(mstrImageFormatType, 800, 800);

            if (objImage == null)
            {
                throw new System.Exception("Could not read this image file");
            }

            await using System.IO.MemoryStream objMemoryStream = new System.IO.MemoryStream();

            await objImage.OpenReadStream(maxAllowedSize: 3 * 1024 * 1024).CopyToAsync(objMemoryStream);

            System.Byte[] abytImage = new System.Byte[objMemoryStream.Length];
            objMemoryStream.Seek(0, System.IO.SeekOrigin.Begin);
            await objMemoryStream.ReadAsync(abytImage, 0, abytImage.Length);
            await objMemoryStream.DisposeAsync();

            System.String strImageId = subGenerateRandomHex();
            System.String strImageBase64 = System.Convert.ToBase64String(abytImage, 0, abytImage.Length);

            await mobjJSRichTextEditor.InvokeVoidAsync("insertImage", $"data:{mstrImageFormatType};base64,{strImageBase64}", strImageId);

            mdictImages.Add(strImageId, strImageBase64);
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region subHandleLinkStyle
    private async void subHandleLinkStyle()
    {
        if (prpIsDisabled) return;

        try
        {
            if (mobjJSRichTextEditor != null && fobjLinkModalRef != null)
            {
                Modal.enumCloseAction enmCloseAction = await fobjLinkModalRef.fncShowModal();

                if (enmCloseAction == Modal.enumCloseAction.typConfirm && !System.String.IsNullOrWhiteSpace(fstrModalLink))
                {
                    await mobjJSRichTextEditor.InvokeVoidAsync("applyStyle", "link", fstrModalLink);
                }
            }
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region fncValidateUri
    private System.Boolean fncValidateUri(System.String? pstrValue)
    {
        if (!System.String.IsNullOrEmpty(pstrValue) && System.Uri.TryCreate(pstrValue, System.UriKind.Absolute, out System.Uri? objURI)
        && (objURI?.Scheme == System.Uri.UriSchemeHttp || objURI?.Scheme == System.Uri.UriSchemeHttps))
        {
            return true;
        }
        else
        {
            fstrModalLinkErrorMessage = "Invalid Link";
            return false;
        }
    }
    #endregion

    #region subHandleApplyStyle
    private async void subHandleApplyStyle(System.String pstrStyle)
    {
        if (prpIsDisabled) return;

        try
        {
            if (mobjJSRichTextEditor != null)
            {
                await mobjJSRichTextEditor.InvokeVoidAsync("applyStyle", pstrStyle);
            }
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region subHandleTextAlign
    private async void subHandleTextAlign(Classes.enumTextAlign penmTextAlignType)
    {
        if (prpIsDisabled) return;

        try
        {
            if (mobjJSRichTextEditor != null)
            {
                await mobjJSRichTextEditor.InvokeVoidAsync("setTextAlign", penmTextAlignType.ToString());
            }
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region subHandleBlockTypeChange
    private async void subHandleBlockTypeChange(Microsoft.AspNetCore.Components.ChangeEventArgs pobjArgs)
    {
        if (prpIsDisabled) return;

        try
        {
            if (mobjJSRichTextEditor != null && pobjArgs.Value.ToString() != Classes.enumBlockType.typImage.ToString())
            {
                await mobjJSRichTextEditor.InvokeVoidAsync("setBlockType", pobjArgs.Value.ToString());
            }
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
    }
    #endregion

    #region subSetValue
    [Microsoft.JSInterop.JSInvokable("subSetValue")]
    public async void subSetValue(System.String pstrJsonContentValue)
    {
        try
        {
            System.Text.Json.JsonSerializerOptions? objJsonOptions = new System.Text.Json.JsonSerializerOptions();
            objJsonOptions.Converters.Add(new System.Text.Json.Serialization.JsonStringEnumConverter());

            System.Collections.Generic.List<Classes.cRichTextBlock>? objContent = System.Text.Json.JsonSerializer.Deserialize<List<Classes.cRichTextBlock>>(pstrJsonContentValue, objJsonOptions);

            for (System.Int32 i = 0; i < (objContent?.Count ?? 0); i++)
            {
                if (objContent?.ElementAtOrDefault(i)?.menmBlockType == Classes.enumBlockType.typImage)
                {
                    objContent[i].mobjImageData!.mstrSrc = $"data:{mstrImageFormatType};base64,{mdictImages[objContent[i].mobjImageData!.mstrImageId]}";
                }
            }

            mobjCurrentValue = objContent;
        }
        catch (System.Exception ex)
        {
            subSetLastError(System.Reflection.MethodBase.GetCurrentMethod().Name, ex.Message);
        }
        finally
        {
            StateHasChanged();
        }
    }
    #endregion

    #region fncRenderContent
    /// <summary>
    /// Generates the RenderFragment based on the output of the RichTextInput component. This can be used in blazor code as:
    ///
    /// @RichTextInput.fncRenderContent(falobjYourOutputVariable)
    ///
    /// Note: If you want to use custom css styling, pass in a pstrUniqueBlockId (optional param), otherwise it is set to a random hex value incase multiple different blocks are rendered on the same page
    /// </summary>
    /// <param name="palobjRichTextBlocks">The output generated from the Rich Text Input</param>
    /// <param name="pstrUniqueBlockId">If no value is given, the block will have a random value of 6 hex characters (i.e. "2FA08B")</param>
    /// <returns>RenderFragment for blazor (used @RichTextInput.fncRenderContent() in a razor page)</returns>
    public static Microsoft.AspNetCore.Components.RenderFragment fncRenderContent(System.Collections.Generic.List<Classes.cRichTextBlock> palobjRichTextBlocks, System.String pstrUniqueBlockId = "")
    {
        if (System.String.IsNullOrEmpty(pstrUniqueBlockId)) pstrUniqueBlockId = subGenerateRandomHex();

        return new Microsoft.AspNetCore.Components.RenderFragment((builder) =>
        {
            System.Boolean blnIsFirstBlockFullImage = (palobjRichTextBlocks?.FirstOrDefault()?.mobjImageData?.mintWidth ?? 0) == 100;

            System.Int32 mintSeq = 0; // Sequence number for the RenderTreeBuilder
            builder.OpenElement(mintSeq++, "div");
            builder.AddAttribute(mintSeq++, "style", $"padding: {(!blnIsFirstBlockFullImage ? "16px" : "0")} 20px 16px 20px;");
            builder.AddAttribute(mintSeq++, "class", $"rte-output-display__{pstrUniqueBlockId}");
            if (palobjRichTextBlocks == null || !palobjRichTextBlocks.Any())
            {
                builder.AddAttribute(mintSeq++, "style", "color: #555;");
                builder.AddContent(mintSeq++, "No content available.");
                builder.CloseElement();
                builder.OpenElement(mintSeq++, "style");
                builder.AddContent(mintSeq++, subSetBlockStyles(pstrUniqueBlockId));
                builder.CloseElement();
                return;
            }
            foreach (Classes.cRichTextBlock objRichTextBlock in palobjRichTextBlocks)
            {
                // Render based on menmBlockType
                switch (objRichTextBlock.menmBlockType)
                {
                    case Classes.enumBlockType.typBody:
                        builder.OpenElement(mintSeq++, "div");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "style", GetBlockStyle(objRichTextBlock));
                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                    case Classes.enumBlockType.typImage:
                        if (objRichTextBlock.mobjImageData != null)
                        {
                            builder.OpenElement(mintSeq++, "div");
                            builder.AddAttribute(mintSeq++, "style", $@"position: relative;margin-bottom: 8px;{(!System.String.IsNullOrWhiteSpace(objRichTextBlock.mobjImageData.mstrCaption) ? "padding-bottom:24px;" : "")}display:flex;align-items:center;" +
                                objRichTextBlock.mobjImageData.menmImageAlign switch
                                {
                                    Classes.enumTextAlign.typLeft => "justify-content: flex-start;",
                                    Classes.enumTextAlign.typRight => "justify-content: flex-end;",
                                    _ => "justify-content: center;"
                                });
                            builder.OpenElement(mintSeq++, "div");
                            builder.AddAttribute(mintSeq++, "style", $"position: relative; width: {objRichTextBlock.mobjImageData.mintWidth}%; aspect-ratio: 1 / {objRichTextBlock.mobjImageData.mintHeightRatio};");
                            builder.OpenElement(mintSeq++, "img");
                            builder.AddAttribute(mintSeq++, "src", objRichTextBlock.mobjImageData.mstrSrc);
                            builder.AddAttribute(mintSeq++, "alt", objRichTextBlock.mobjImageData.mstrAlt ?? objRichTextBlock.mobjImageData.mstrCaption ?? "Inserted Image");
                            builder.AddAttribute(mintSeq++, "style", $"width: {(objRichTextBlock.mobjImageData.mintWidth < 100 ? "100%" : $"calc({objRichTextBlock.mobjImageData.mintWidth}% + 40px)")}; height: 100%; object-fit: cover;{(blnIsFirstBlockFullImage ? "position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);" : "")}");
                            builder.CloseElement();
                            if (!System.String.IsNullOrWhiteSpace(objRichTextBlock.mobjImageData.mstrCaption))
                            {
                                builder.OpenElement(mintSeq++, "p");
                                builder.AddAttribute(mintSeq++, "style", "position: absolute;bottom: 0;left: 0;transform: translateY(100%);padding: 4px 3px;color: #444; width: 100%;line-height: 1rem;");
                                builder.AddContent(mintSeq++, objRichTextBlock.mobjImageData.mstrCaption);
                                builder.CloseElement();
                            }
                            builder.CloseElement();
                            builder.CloseElement();
                        }
                        break;
                    case Classes.enumBlockType.typHeading1:
                        builder.OpenElement(mintSeq++, "h2");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "style", GetBlockStyle(objRichTextBlock));
                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                    case Classes.enumBlockType.typHeading2:
                        builder.OpenElement(mintSeq++, "h3");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "style", GetBlockStyle(objRichTextBlock));
                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                    case Classes.enumBlockType.typHeading3:
                        builder.OpenElement(mintSeq++, "h4");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "style", GetBlockStyle(objRichTextBlock));
                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                    case Classes.enumBlockType.typBlockQuote:
                        builder.OpenElement(mintSeq++, "blockquote");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "style", GetBlockStyle(objRichTextBlock));
                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                    case Classes.enumBlockType.typBulletList:
                        builder.OpenElement(mintSeq++, "div");
                        builder.AddAttribute(mintSeq++, "class", "text-block");
                        builder.AddAttribute(mintSeq++, "data-indentation", objRichTextBlock.mintIndentation);
                        if (objRichTextBlock.mintIndentation > 0) builder.AddAttribute(mintSeq++, "style", $"margin-left: {objRichTextBlock.mintIndentation}rem");

                        if (objRichTextBlock.malobjTextNodes != null)
                        {
                            foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                            {
                                subRenderTextNode(builder, objTextNode, ref mintSeq);
                            }
                        }
                        builder.CloseElement();
                        break;
                }
            }

            builder.OpenElement(mintSeq++, "style");
            builder.AddContent(mintSeq++, subSetBlockStyles(pstrUniqueBlockId));
            builder.CloseElement();

            builder.CloseElement(); // Wrapping div
        });
    }

    private static void subRenderTextNode(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, Classes.cRichTextNode pobjTextNode, ref System.Int32 pintSeq)
    {
        System.Boolean blnIsLink = !System.String.IsNullOrWhiteSpace(pobjTextNode.mstrLink);
        builder.OpenElement(pintSeq++, blnIsLink ? "a" : "span");
        if (blnIsLink) builder.AddAttribute(pintSeq++, "href", pobjTextNode.mstrLink);
        builder.AddAttribute(pintSeq++, "style", subGetNodeStyle(pobjTextNode));
        builder.AddContent(pintSeq++, pobjTextNode.mstrText);
        builder.CloseElement();
    }

    private static System.String GetBlockStyle(Classes.cRichTextBlock objRichTextBlock)
    {
        System.Collections.Generic.List<System.String> alstrStyles = new System.Collections.Generic.List<System.String>();
        if (objRichTextBlock.menmTextAlign != Classes.enumTextAlign.typLeft)
        {
            alstrStyles.Add($"text-align: {objRichTextBlock.menmTextAlign.ToString().Replace("typ", "").ToLower()};");
        }
        if (objRichTextBlock.mintIndentation > 0)
        {
            alstrStyles.Add($"margin-left: {objRichTextBlock.mintIndentation * 2}rem;");
        }
        return string.Join(" ", alstrStyles);
    }

    private static System.String subGetNodeStyle(Classes.cRichTextNode pobjTextNode)
    {
        System.Collections.Generic.List<System.String> alstrStyles = new System.Collections.Generic.List<System.String>();
        if (pobjTextNode.mblnIsBold) alstrStyles.Add("font-weight: bold;");
        if (pobjTextNode.mblnIsItalic) alstrStyles.Add("font-style: italic;");
        if (pobjTextNode.mblnIsUnderline) alstrStyles.Add("text-decoration: underline;");
        return System.String.Join(" ", alstrStyles);
    }

    private static System.String subSetBlockStyles(System.String pstrUniqueBlockId)
    {
        System.Text.StringBuilder objStylesBuilder = new System.Text.StringBuilder();
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " * { font-family: Arial, sans-serif; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h1 { font-size: 1.75rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h2 { font-size: 1.5rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h3 { font-size: 1.25rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " div.text-block { font-size: 1rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " blockquote.text-block { position: relative; padding: 0.5rem; padding-left: 1rem; background-color: #eee; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " blockquote.text-block::before { content: ''; position: absolute; left: 0; top: 0; width: 3px; height: 100%; background-color: #555; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block[data-indentation] { padding-left: 1.5rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block[data-indentation]::before { content: ''; position: absolute; left: 0.75rem; top: 45%; transform: translate(-50%, -50%); width: 5px; aspect-ratio: 1; border-radius: 50%; background-color: black; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block { position: relative; margin-bottom: 0.5rem; line-height: 1.5; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .bold { font-weight: bold; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .italic { font-style: italic; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .underline { text-decoration: underline; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " span[href] { color: blue; }");

        return objStylesBuilder.ToString();
    }
    #endregion

    #region fncRenderContentAsHTML
    /// <summary>
    /// Converts the output from the RichTextInput into a HTML string
    /// </summary>
    /// <param name="palobjRichTextBlocks">The output generated from the Rich Text Input</param>
    /// <param name="pstrUniqueBlockId">If no value is given, the block will have a random value of 6 hex characters (i.e. "2FA08B")</param>
    /// <returns>String of HTML corresponding to the Rich Text output</returns>
    public static System.String fncRenderContentAsHTML(System.Collections.Generic.List<Classes.cRichTextBlock> palobjRichTextBlocks, System.String pstrUniqueBlockId = "")
    {
        if (System.String.IsNullOrEmpty(pstrUniqueBlockId)) pstrUniqueBlockId = subGenerateRandomHex();

        System.Text.StringBuilder builder = new System.Text.StringBuilder();

        System.Boolean blnIsFirstBlockFullImage = (palobjRichTextBlocks?.FirstOrDefault()?.mobjImageData?.mintWidth ?? 0) == 100;

        builder.AppendLine($"<div style=\"padding: {(!blnIsFirstBlockFullImage ? "16px" : "0")} 20px 16px 20px;{(palobjRichTextBlocks == null || !palobjRichTextBlocks.Any() ? "color: #555" : "")}\" class=\"rte-output-display__{pstrUniqueBlockId}\">");

        if (palobjRichTextBlocks == null || !palobjRichTextBlocks.Any())
        {

            builder.AppendLine("No content available.");
            builder.AppendLine("</div>");
            builder.AppendLine("<style>");
            builder.AppendLine(subReturnBlockStylesString(pstrUniqueBlockId));
            builder.AppendLine("</style>");
            return builder.ToString();
        }

        foreach (Classes.cRichTextBlock objRichTextBlock in palobjRichTextBlocks)
        {
            // Render based on menmBlockType
            switch (objRichTextBlock.menmBlockType)
            {
                case Classes.enumBlockType.typBody:
                    builder.AppendLine($"<div class=\"text-block\" style=\"{subGetBlockStyles(objRichTextBlock)}\">");
                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</div>");
                    break;
                case Classes.enumBlockType.typImage:
                    if (objRichTextBlock.mobjImageData != null)
                    {
                        builder.AppendLine("<div ");
                        builder.Append($"style=\"position: relative;margin-bottom: 8px;{(!System.String.IsNullOrWhiteSpace(objRichTextBlock.mobjImageData.mstrCaption) ? "padding-bottom:24px;" : "")}display:flex;align-items:center;\"" +
                            objRichTextBlock.mobjImageData.menmImageAlign switch
                            {
                                Classes.enumTextAlign.typLeft => "justify-content: flex-start;",
                                Classes.enumTextAlign.typRight => "justify-content: flex-end;",
                                _ => "justify-content: center;"
                            });
                        builder.AppendLine("<div ");
                        builder.Append($"style=\"position: relative; width: {objRichTextBlock.mobjImageData.mintWidth}%; aspect-ratio: 1 / {objRichTextBlock.mobjImageData.mintHeightRatio};\">");
                        builder.AppendLine("<img ");
                        builder.Append($"src=\"{objRichTextBlock.mobjImageData.mstrSrc}\" ");
                        builder.Append($"alt=\"{objRichTextBlock.mobjImageData.mstrAlt ?? objRichTextBlock.mobjImageData.mstrCaption ?? "Inserted Image"}\" ");
                        builder.Append($"style=\"width: {(objRichTextBlock.mobjImageData.mintWidth < 100 ? "100%" : $"calc({objRichTextBlock.mobjImageData.mintWidth}% + 40px)")}; height: 100%; object-fit: cover;{(blnIsFirstBlockFullImage ? "position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);" : "")}\" />");
                        if (!System.String.IsNullOrWhiteSpace(objRichTextBlock.mobjImageData.mstrCaption))
                        {
                            builder.AppendLine("<p");
                            builder.Append("style=\"position: absolute;bottom: 0;left: 0;transform: translateY(100%);padding: 4px 3px;color: #444; width: 100%;line-height: 1rem;\">");
                            builder.AppendLine(objRichTextBlock.mobjImageData.mstrCaption);
                            builder.AppendLine("</p>");
                        }
                        builder.AppendLine("</div>");
                        builder.AppendLine("</div>");
                    }
                    break;
                case Classes.enumBlockType.typHeading1:
                    builder.AppendLine("<h2 ");
                    builder.Append("class=\"text-block\" ");
                    builder.Append($"style=\"{subGetBlockStyles(objRichTextBlock)}\">");
                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</h2>");
                    break;
                case Classes.enumBlockType.typHeading2:
                    builder.AppendLine("<h3 ");
                    builder.Append("class=\"text-block\" ");
                    builder.Append($"style=\"{subGetBlockStyles(objRichTextBlock)}\">");
                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</h3>");
                    break;
                case Classes.enumBlockType.typHeading3:
                    builder.AppendLine("<h4 ");
                    builder.Append("class=\"text-block\" ");
                    builder.Append($"style=\"{subGetBlockStyles(objRichTextBlock)}\">");
                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</h4>");
                    break;
                case Classes.enumBlockType.typBlockQuote:
                    builder.AppendLine("<blockquote ");
                    builder.Append("class=\"text-block\" ");
                    builder.Append($"style=\"{subGetBlockStyles(objRichTextBlock)}\">");
                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</blockquote>");
                    break;
                case Classes.enumBlockType.typBulletList:
                    builder.AppendLine("<div ");
                    builder.Append($"data-indentation=\"{objRichTextBlock.mintIndentation}\" ");
                    if (objRichTextBlock.mintIndentation > 0) builder.Append("style=\"margin-left: {objRichTextBlock.mintIndentation}rem;\" ");
                    builder.Append("class=\"text-block\">");

                    if (objRichTextBlock.malobjTextNodes != null)
                    {
                        foreach (Classes.cRichTextNode objTextNode in objRichTextBlock.malobjTextNodes)
                        {
                            subConvertTextNode(builder, objTextNode);
                        }
                    }
                    builder.AppendLine("</div>");
                    break;
            }
        }

        builder.AppendLine("<style>");
        builder.AppendLine(subReturnBlockStylesString(pstrUniqueBlockId));
        builder.AppendLine("</style>");

        builder.AppendLine("</div>"); // Wrapping div

        return builder.ToString();
    }

    private static void subConvertTextNode(System.Text.StringBuilder pobjBuilder, Classes.cRichTextNode pobjTextNode)
    {
        if (!System.String.IsNullOrWhiteSpace(pobjTextNode.mstrLink))
        {
            pobjBuilder.AppendLine("<a ");
            pobjBuilder.Append($"href=\"{pobjTextNode.mstrLink}\" ");
        }
        else
        {
            pobjBuilder.AppendLine("<span ");
        }
        pobjBuilder.Append($"style=\"{subGetTextNodeStyle(pobjTextNode)}\">");
        pobjBuilder.AppendLine(pobjTextNode.mstrText);
        pobjBuilder.AppendLine($"</{(!System.String.IsNullOrWhiteSpace(pobjTextNode.mstrLink) ? "a" : "span")}>");
    }

    private static System.String subGetBlockStyles(Classes.cRichTextBlock objRichTextBlock)
    {
        System.Collections.Generic.List<System.String> alstrStyles = new System.Collections.Generic.List<System.String>();
        if (objRichTextBlock.menmTextAlign != Classes.enumTextAlign.typLeft)
        {
            alstrStyles.Add($"text-align: {objRichTextBlock.menmTextAlign.ToString().Replace("typ", "").ToLower()};");
        }
        if (objRichTextBlock.mintIndentation > 0)
        {
            alstrStyles.Add($"margin-left: {objRichTextBlock.mintIndentation * 2}rem;");
        }
        return System.String.Join(" ", alstrStyles);
    }

    private static System.String subGetTextNodeStyle(Classes.cRichTextNode pobjTextNode)
    {
        System.Collections.Generic.List<System.String>
            alstrStyles = new System.Collections.Generic.List<System.String>
                ();
        if (pobjTextNode.mblnIsBold) alstrStyles.Add("font-weight: bold;");
        if (pobjTextNode.mblnIsItalic) alstrStyles.Add("font-style: italic;");
        if (pobjTextNode.mblnIsUnderline) alstrStyles.Add("text-decoration: underline;");
        return System.String.Join(" ", alstrStyles);
    }

    private static System.String subReturnBlockStylesString(System.String pstrUniqueBlockId)
    {
        System.Text.StringBuilder objStylesBuilder = new System.Text.StringBuilder();
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " * { font-family: Arial, sans-serif; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h1 { font-size: 1.75rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h2 { font-size: 1.5rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " h3 { font-size: 1.25rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " div.text-block { font-size: 1rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " blockquote.text-block { position: relative; padding: 0.5rem; padding-left: 1rem; background-color: #eee; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " blockquote.text-block::before { content: ''; position: absolute; left: 0; top: 0; width: 3px; height: 100%; background-color: #555; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block[data-indentation] { padding-left: 1.5rem; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block[data-indentation]::before { content: ''; position: absolute; left: 0.75rem; top: 45%; transform: translate(-50%, -50%); width: 5px; aspect-ratio: 1; border-radius: 50%; background-color: black; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .text-block { position: relative; margin-bottom: 0.5rem; line-height: 1.5; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .bold { font-weight: bold; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .italic { font-style: italic; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " .underline { text-decoration: underline; }");
        objStylesBuilder.AppendLine(".rte-output-display__" + pstrUniqueBlockId + " span[href] { color: blue; }");

        return objStylesBuilder.ToString();
    }
    #endregion

    #region IDispose.Dispose
    public void Dispose()
    {
        mobjJSRichTextEditor?.InvokeVoidAsync("dispose");
    }
    #endregion
}